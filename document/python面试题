1.*arg,**kwargs参数的含义及为什么要使用它们
答：如果我们不确定往一个函数中传入多少参数，或者我们希望以元组（tuple）或者列表（list）的形式传参数的时候，我们可以使用*args（单星号）。
如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs（双星号），args、kwargs两个标识符是约定俗成的用法。

另一种答法：当函数的参数前面有一个星号*号的时候表示这是一个可变的位置参数，两个星号**表示这个是一个可变的关键词参数。
星号*把序列或者集合解包（unpack）成位置参数，两个星号**把字典解包成关键词参数。

代码辅助理解
tempList=[1,2,3]
tempTuple=(2,3,4)
tempDict={'s':3,'m':4,'c'5}

def testFunc(*args,**kwargs):
    print(arg,kwargs)
    
testFunc()           #(){}
testFunc(*tempList)   #(1,2,3){}
testFunc(*tempTuple)    #(2,3,4){}
testFunc(*tempDict)     #('s','m','c'),{}
testFunc(**tempDict)    #(),{'s':3,'m':4,'c'5}
testFunc(*args,**tempDict)  #(1,2,3){'s':3,'m':4,'c'5}

2.谈一谈Python的装饰器
装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。
它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。

import logging
def log(text):
  def decorator(func):
    def wrapper(*args,**kwargs):
      func(*args,**kwargs)
      print('%s %s' %(text,func.__name__))
    print('%s %s'%('start',func.__name__))
    return wrapper
  return decorator
  
 @log('end')
 def now():
    print('2016')
  
 now()
 
 3.简要描述Python的垃圾回收机制（garbage collection）
 Python中的垃圾回收是以引用计数为主，标记-清除和分代收集为辅。
    引用计数：Python在内存中存储每个对象的引用计数，如果计数变成0，该对象就会消失，分配给该对象的内存就会释放出来。
    标记-清除：一些容器对象，比如list、dict、tuple，instance等可能会出现引用循环，对于这些循环，垃圾回收器会定时回收这些循环
            （对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边）。
    分代收集：Python把内存根据对象存活时间划分为三代，对象创建之后，垃圾回收器会分配它们所属的代。每个对象都会被分配一个代，
             而被分配更年轻的代是被优先处理的，因此越晚创建的对象越容易被回收。

4.Python多线程（multi-threading）
Python并不支持真正意义上的多线程，Python提供了多线程包。Python中有一个叫Global Interpreter Lock（GIL）的东西，
它能确保你的代码中永远只有一个线程在执行。经过GIL的处理，会增加执行的开销。这就意味着如果你先要提高代码执行效率，
使用threading不是一个明智的选择，当然如果你的代码是IO密集型，多线程可以明显提高效率，相反如果你的代码是CPU密集型的这种情况下多线程大部分是鸡肋。

5.说明os,sys模块不同，并列举常用的模块方法？
  官方文档：
      os模板提供了一种方便的使用操作系统函数的方法
      sys模板可供访问由解释器使用或维护的变量和与解释器交互的函数
  另一种回答：

  os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口。sys模块负责程序与Python解释器的交互，提供了一系列的函数和变量用户操作Python
  运行时的环境。
  [html] view plaincopyprint?

    os.remove()删除文件  
    os.rename()重命名文件  
    os.walk()生成目录树下的所有文件名  
    os.chdir()改变目录  
    os.mkdir/makedirs创建目录/多层目录  
    os.rmdir/removedirs删除目录/多层目录  
    os.listdir()列出指定目录的文件  
    os.getcwd()取得当前工作目录  
    os.chmod()改变目录权限  
    os.path.basename()去掉目录路径，返回文件名  
    os.path.dirname()去掉文件名，返回目录路径  
    os.path.join()将分离的各部分组合成一个路径名  
    os.path.split()返回（dirname(),basename())元组  
    os.path.splitext()(返回filename,extension)元组  
    os.path.getatime\ctime\mtime分别返回最近访问、创建、修改时间  
    os.path.getsize()返回文件大小  
    os.path.exists()是否存在  
    os.path.isabs()是否为绝对路径  
    os.path.isdir()是否为目录  
    os.path.isfile()是否为文件  


sys 常用方法

[html] view plaincopyprint?

    sys.argv           命令行参数List，第一个元素是程序本身路径    
    sys.modules.keys() 返回所有已经导入的模块列表    
    sys.exc_info()     获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息    
    sys.exit(n)        退出程序，正常退出时exit(0)    
    sys.hexversion     获取Python解释程序的版本值，16进制格式如：0x020403F0    
    sys.version        获取Python解释程序的版本信息    
    sys.maxint         最大的Int值    
    sys.maxunicode     最大的Unicode值    
    sys.modules        返回系统导入的模块字段，key是模块名，value是模块    
    sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值    
    sys.platform       返回操作系统平台名称    
    sys.stdout         标准输出   
    sys.stdin          标准输入   
    sys.stderr         错误输出   
    sys.exc_clear()    用来清除当前线程所出现的当前的或最近的错误信息   
    sys.exec_prefix    返回平台独立的python文件安装的位置   
    sys.byteorder      本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'   
    sys.copyright      记录python版权相关的东西   
    sys.api_version    解释器的C的API版本   
    sys.version_info    

  6.什么是lambda表达式？它有什么好处？
  简单来说，lambda表达式通常是当你需要使用一个函数，但是又不想费脑袋去命名一个函数的时候使用，也就是通常所说的匿名函数。

lambda表达式一般的形式是：关键词lambda后面紧接一个或多个参数，紧接一个冒号“：”，紧接一个表达式。lambda表达式是一个表达式不是一个语句。
f=lambda x,y,z : z+y+z
print(f(4,2,6))

L={'f1':(lambda x,y : x**2+y**2),
   'f2':(lambda x,y :x**3+y**3),
   'f3':(lambda x,y:x**4+y**3)
}
print(L['f2'](3,2))

7.Python中pass语句的作用是什么？
  pass语句什么也不做，一般作为占位符或者创建占位程序，pass语句不会执行任何操作，比如：
  while False:
  pass
  pass通常用来创建一个最简单的类：
  class MyEmptyClass:
  pass
  pass在软件设计阶段也经常用来作为TODO，提醒实现相应的实现，比如：
  def initlog(*args):
  pass #please implement this

8.Python是如何进行类型转换的
  Python提供了将变量或值从一种类型转换为另一种类型的内置方法。

9.python里面的浅拷贝与深拷贝
  Python中对象之间的赋值是按引用传递的，如果要拷贝对象需要使用标准模板中的copy
      copy.copy：浅拷贝，只拷贝父对象，不拷贝父对象的子对象。
      copy.deepcopｙ：深拷贝，拷贝父对象和子对象。

10.__new__和__init__的区别


    __init__为初始化方法，__new__方法是真正的构造函数。

    __new__是实例创建之前被调用，它的任务是创建并返回该实例，是静态方法

    __init__是实例创建之后被调用的，然后设置对象属性的一些初始值。

总结：__new__方法在__init__方法之前被调用，并且__new__方法的返回值将传递给__init__方法作为第一个参数，最后__init__给这个实例设置一些参数。

11.Python中单下划线和双下划线分别是什么？
   __name__：一种约定，Python内部的名字，用来与用户自定义的名字区分开，防止冲突
   _name：一种约定，用来指定变量私有
   __name：解释器用_classname__name来代替这个名字用以区别和其他类相同的命名
   
   
12.说一说Python自省。
  自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型。简单一句话就是运行时能够获得对象的类型。
  比如：
  type()
  dir()
  getattr()
  hasattr()
  isinstance()  

13.如何用Python输出一个Fibonacci数列
  代码如下：
  a,b=0,1
  while b<100:
    print(b)
    a,b=b,a+b
  
14.介绍一下Python的range()函数？
  如果需要迭代一个数字序列的话，可以使用range()函数，range()函数可以生成等差级数。
  如例：
  for i in range(5)
  print(i)
  这段代码将输出0, 1, 2, 3, 4五个数字
  range(10)会产生10个值， 也可以让range()从另外一个数字开始，或者定义一个不同的增量，甚至是负数增量
  range(5, 10)从5到9的五个数字
  range(0, 10, 3) 增量为三， 包括0,3,6,9四个数字
  range(-10, -100, -30) 增量为-30， 包括-10, -40, -70
  可以一起使用range()和len()来迭代一个索引序列
  例如：
  a = ['Nina', 'Jim', 'Rainman', 'Hello']
  for i in range(len(a)):
  print(i, a[i])

15.介绍一下except的用法和作用？
Python的except用来捕获所有异常， 因为Python里面的每次错误都会抛出 一个异常，所以每个程序的错误都被当作一个运行时错误。
一下是使用except的一个例子：
try:
  foo = opne(”file”) #open被错写为opne
except:
  sys.exit(”could not open file!”)
因为这个错误是由于open被拼写成opne而造成的，然后被except捕获，所以debug程序的时候很容易不知道出了什么问题
下面这个例子更好点：
try:
  foo = opne(”file”) # 这时候except只捕获IOError
except IOError:
  sys.exit(”could not open file”)

16.如何用Python来进行查询和替换一个文本字符串？
  可以使用sub()方法来进行查询和替换，sub方法的格式为：sub(replacement, string[, count=0])
  replacement是被替换成的文本
  string是需要被替换的文本
  count是一个可选参数，指最大被替换的数量
  例子：
  import re
  p = re.compile(’(blue|white|red)’)
  print(p.sub(’colour’,’blue socks and red shoes’))
  print(p.sub(’colour’,’blue socks and red shoes’, count=1))
  输出：
  colour socks and colour shoes
  colour socks and red shoes
  subn()方法执行的效果跟sub()一样，不过它会返回一个二维数组，包括替换后的新的字符串和总共替换的数量
  例如：
  import re
  p = re.compile(’(blue|white|red)’)
  print(p.subn(’colour’,’blue socks and red shoes’))
  print(p.subn(’colour’,’blue socks and red shoes’, count=1))
  输出
  (’colour socks and colour shoes’, 2)
  (’colour socks and red shoes’, 1)
  
17.Python里面search()和match()的区别？
    match（）函数只检测RE是不是在string的开始位置匹配， search()会扫描整个string查找匹配, 也就是说match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none
    例如：
    print(re.match(’super’, ’superstition’).span())会返回(0, 5)
    而print(re.match(’super’, ‘insuperable’))则返回None
    search()会扫描整个字符串并返回第一个成功的匹配
    例如：print(re.search(’super’, ’superstition’).span())返回(0, 5)
    print(re.search(’super’, ‘insuperable’).span())返回(2, 7)
    
 18.用Python匹配HTML tag的时候，<.*>和<.*?>有什么区别？
     当重复匹配一个正则表达式时候， 例如<.*>, 当程序执行匹配的时候，会返回最大的匹配值
    例如：
    import re
    s = ‘’
    print(re.match(’<.*>’, s).group())
    会返回一个匹配而不是
    而
    import re
    s = ‘’
    print(re.match(’<.*?>’, s).group())
    则会返回
    <.*>这种匹配称作贪心匹配 <.*?>称作非贪心匹配
    
19.有两个序列a,b，大小都为n,序列元素的值任意整形数，无序；要求：通过交换a,b中的元素，使[序列a元素的和]与[序列b元素的和]之间的差最小。

20.如何在一个function里面设置一个全局的变量？
  解决方法是在function的开始插入一个global声明：
  def f()
    global x
    
21.有没有一个工具可以帮助查找python的bug和进行静态的代码分析？
  有，PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告
  Pylint是另外一个工具可以进行coding standard检查。
  
 22.如何用Python来发送邮件
   可以使用smtplib标准库。
  以下代码可以在支持SMTP监听器的服务器上执行。
  import sys, smtplib
  fromaddr = raw_input(”From: “)
  toaddrs = raw_input(”To: “).split(’,’)
  print “Enter message, end with ^D:”
  msg = ”
  while 1:
  line = sys.stdin.readline()
  if not line:
  break
  msg = msg + line
  # 发送邮件部分
  server = smtplib.SMTP(’localhost’)
  server.sendmail(fromaddr, toaddrs, msg)
  server.quit()
  
22.Python里面如何生成随机数？
  标准库random实现了一个随机数生成器，实例代码如下：
  import random
  random.random()
  它会返回一个随机的0和1之间的浮点数
  
23.请写出一段Python代码实现删除一个list里面的重复元素
可以先把list重新排序，然后从list的最后开始扫描，代码如下：
if List:
  List.sort()
last = List[-1]
for i in range(len(List)-2, -1, -1):
  if last==List[i]: del List[i]
  else: last=List[i]
  
24.Python里面如何实现tuple和list的转换
  函数tuple(seq)可以把所有可迭代的(iterable)序列转换成一个tuple, 元素不变，排序也不变。
  例如，tuple([1,2,3])返回(1,2,3), tuple(’abc’)返回(’a’.’b’,’c’).如果参数已经是一个tuple的话，
  函数不做任何拷贝而直接返回原来的对象，所以在不确定对象 是不是tuple的时候来调用tuple()函数也不是很耗费的。
  函数list(seq)可以把所有的序列和可迭代的对象转换成一个list,元素不变，排序也不变。
  例如 list([1,2,3])返回(1,2,3), list(’abc’)返回['a', 'b', 'c']。如果参数是一个list, 她会像set[:]一样做一个拷贝
  
25.如何反序的迭代一个序列？
如果是一个list, 最快的解决方案是：
list.reverse()
try:
  for x in list:
  “do something with x”
finally:
  list.reverse()
如果不是list, 最通用但是稍慢的解决方案是：
for i in range(len(sequence)-1, -1, -1):
  x = sequence[i]
  
26.Python如何实现单例模式？
Python有两种方式可以实现单例模式，下面两个例子使用了不同的方式实现单例模式：
1.
  class Singleton(type):
    def __init__(cls, name, bases, dict):
      super(Singleton, cls).__init__(name, bases, dict)
      cls.instance = None
    def __call__(cls, *args, **kw):
      if cls.instance is None:
        cls.instance = super(Singleton, cls).__call__(*args, **kw)
    return cls.instance
  class MyClass(object):
    __metaclass__ = Singleton
  print MyClass()
  print MyClass()
2. 使用decorator来实现单例模式
def singleton(cls):
  instances = {}
def getinstance():
  if cls not in instances:
    instances[cls] = cls()
    return instances[cls]
  return getinstance

@singleton
class MyClass:
…

27.在判断object是否是class的instances时，type和isinstance函数的区别？
  type(obj) => <type 'instance'>
  type(cls) => <type 'classobj'>
  由上可知，所有obj type后统一为 instance type； 而cls type后统一为classobj type
  isinstance(obj,class)，如果object是class的instance，返回True。
  
  28.通过重写内建函数，实现文件open之前检查文件格式？
  [html] view plaincopyprint?

    <span style="font-size:14px;">#! /usr/bin/env python  
    # -*- coding: utf-8 -*-  
    # vim: tabstop=4 shiftwidth=4 softtabstop=4  
      
    def open(filename,mode):  
        import __builtin__  
          
        file = __builtin__.open(filename,mode)  
          
        if file.read(5) not in("GIF87", "GIF89"):   
            raise IOError, "not aGIF file"  
        file.seek(0)   
        return file  
          
    fp = open("sample/test.gif","r")  
    print len(fp.read()), "bytes"</span>
    
 29.重新实现str.strip()，注意不能使用string.*strip()
 [html] view plaincopyprint?

    <span style="font-size:14px;">#! /usr/bin/env python  
    # -*- coding: utf-8 -*-  
    # vim: tabstop=4 shiftwidth=4 softtabstop=4  
      
      
    # TODO rstrip  
    def rightStr(string,split=' '):  
        endind = string.rfind(split)  
        res = string  
        while endind != -1 and endind == len(res)-1:  
            res = res[:endind]  
            endind = res.rfind(split)  
          
        return res  
      
      
    # TODO lstrip  
    def leftStr(string,split=' '):  
        startind = string.find(split)  
        res = string  
        while startind != -1 and startind == 0:  
            res = res[startind+1:]  
            startind=res.find(split)  
              
        return res  
      
    def main():  
          
        word='aa    asdf  aa  '  
        stripstr=' '  
          
        lenth = len(word)  
        res=word  
        # leftstrip  
        if word[0] == stripstr:  
            res=leftStr(res)  
          
        # rightstrip  
        if word[len(word)-1] == stripstr:  
            res=rightStr(res)  
          
        print res  
      
    if __name__ == "__main__":  
        main()  
        </span> 
        
 30.os.path和sys.path的区别？
 os.path是module，包含了各种处理长文件名(路径名)的函数。

例如：

[html] view plaincopyprint?

    #! /usr/bin/env python  
    # -*- coding: utf-8 -*-  
    # vim: tabstop=4 shiftwidth=4 softtabstop=4  
      
    import os  
    filename = "my/little/pony"  
    print "using", os.name, "..."  
    print "split", "=>", os.path.split(filename)  
    print "splitext", "=>", os.path.splitext(filename)  
    print "dirname", "=>", os.path.dirname(filename)  
    print "basename", "=>", os.path.basename(filename)  

 

sys.path是由目录名构成的列表，Python 从中查找扩展模块( Python 源模块, 编译模块,或者二进制扩展). 启动 Python 时,这个列表从根据内建规则,
PYTHONPATH 环境变量的内容, 以及注册表( Windows 系统)等进行初始化. 

31.如何匹配<html><title></title></html>得到<html>
[html] view plaincopyprint?

    >>> import re  
    >>> str = r'<html><title></title></html>'  
    >>> p = re.compile(r'<.*?>')  
    >>> print p.match(str).group(0) 
    
32.重新实现filter，map，reduce。
[html] view plaincopyprint?

    #! /usr/bin/env python  
    # -*- coding: utf-8 -*-  
    # vim: tabstop=4 shiftwidth=4 softtabstop=4  
      
    def filter_impl(func, argvs):  
        res = []  
          
        for argv in argvs:  
            if func(argv):  
                res.append(argv)  
          
        return res  
      
      
    # check filter impl  
    print "filter ==>"  
    print filter_impl(lambda x: x<4, range(1,10))  
    print filter(lambda x: x<4, range(1,10))  
      
    def map_impl(func, argvs):  
      
        res = []  
        for argv in argvs:  
            res.append(func(argv))  
              
        return res  
      
    # check map impl  
      
    print "map ==>"  
    print map_impl(lambda x: x*10, range(1,5))  
    print map(lambda x: x*10, range(1,5))  
      
    def reduce_impl(func, argvs, startVal=None):  
          
        if startVal is not None:  
            argv1 = startVal  
        else:  
            argv1 = argvs[0]  
          
        for argv2 in argvs[1:]:  
            argv1 = func(argv1, argv2)  
          
        return argv1  
              
    # check reduce impl  
    print "reduce ==>"  
    print reduce_impl(lambda x,y: x*y, range(1,4),20)  
    print reduce(lambda x,y: x*y, range(1,4),20)  

Result:

filter ==>
[1, 2, 3]
[1, 2, 3]
map ==>
[10, 20, 30, 40]
[10, 20, 30, 40]
reduce ==>
120
120

33.解释生成器(generator)与函数的不同，并实现和使用简单generator？
生成器和函数的主要区别在于函数 return a value，生成器 yield a value同时标记或记忆 point of the yield 以便于在下次调用时从标记点恢复执行。 yield 使函数转换成生成器，而生成器反过来又返回迭代器。

[html] view plaincopyprint?

    #! /usr/bin/env python  
    # -*- coding: utf-8 -*-  
    # vim: tabstop=4 shiftwidth=4 softtabstop=4  
      
    def gem():  
        yield "first"  
        yield "second"  
        yield "third"  
          
    for res in gem():  
        print res  

34.设计实现遍历目录与子目录，抓取.pyc文件?
[html] view plaincopyprint?

    #! /usr/bin/env python  
    # -*- coding: utf-8 -*-  
    # vim: tabstop=4 shiftwidth=4 softtabstop=4  
      
    # 1. for-in dir/subdir to get the filesname  
    # 2. splitext filename to filter  
      
    import os  
      
    def getFiles(dir, suffix):  
          
        res = []  
        for root,directory,files in os.walk(dir):  
            for filename in files:  
                name, suf = os.path.splitext(filename)  
                if suf == suffix:  
                    res.append(os.path.join(root, filename))  
        return res  
      
    for file in getFiles("./", '.py'):  
        print file  

35.以下的代码的输出将是什么? 说出你的答案并解释
	class Parent(object):
	 x = 1 
	class Child1(Parent):
	 pass
	class Child2(Parent):
	 pass
	print Parent.x, Child1.x, Child2.x
	Child1.x = 2
	print Parent.x, Child1.x, Child2.x
	Parent.x = 3
	print Parent.x, Child1.x, Child2.x
  
  
  答案

　　以上代码的输出是：
	1 1 1
	1 2 1
	3 2 3
  
36.以下的代码的输出将是什么? 说出你的答案并解释？
def div1(x,y):
02
	 print("%s/%s = %s" % (x, y, x/y))
03
	  
04
	def div2(x,y):
05
	 print("%s//%s = %s" % (x, y, x//y))
06
	  
07
	div1(5,2)
08
	div1(5.,2)
09
	div2(5,2)
10
	div2(5.,2.)

　　答案

　　这个答案实际依赖于你使用的是 Python 2 还是 Python 3。

　　在 Python 3 中，期望的输出是：
1
	5/2 = 2.5
2
	5.0/2 = 2.5
3
	5//2 = 2
4
	5.0//2.0 = 2.0

　　在 Python 2 中，尽管如此，以上代码的输出将是：
1
	5/2 = 2
2
	5.0/2 = 2.5
3
	5//2 = 2
4
	5.0//2.0 = 2.0

　　默认，如果两个操作数都是整数，Python 2 自动执行整型计算。结果，5/2 值为 2，然而 5./2 值为 ```2.5``。

　　注意，尽管如此，你可以在 Python 2 中重载这一行为（比如达到你想在 Python 3 中的同样结果），通过添加以下导入：
1
	from __future__ import division

　　也需要注意的是“双划线”（//）操作符将一直执行整除，而不管操作数的类型，这就是为什么 5.0//2.0 值为 2.0。

　　注： 在 Python 3 中，/ 操作符是做浮点除法，而 // 是做整除（即商没有余数，比如 10 // 3 其结果就为 3，余数会被截除掉，而 (-7) // 3 的
  结果却是 -3。这个算法与其它很多编程语言不一样，需要注意，它们的整除运算会向0的方向取值。而在 Python 2 中，/ 就是整除，
  即和 Python 3 中的 // 操作符一样，）
  
37.以下代码将输出什么?
  list = ['a', 'b', 'c', 'd', 'e']
  print list[10:]
  以上代码将输出 []，并且不会导致一个 IndexError。

    正如人们所期望的，试图访问一个超过列表索引值的成员将导致 IndexError（比如访问以上列表的 list[10]）。
    尽管如此，试图访问一个列表的以超出列表成员数作为开始索引的切片将不会导致 IndexError，并且将仅仅返回一个空列表。
    
38.以下的代码的输出将是什么? 说出你的答案并解释？
　　def multipliers():
      return [lambda x : i*x for i in range(4)]
    
    print[m(2) for m in multipliers()]
    
    以上代码的输出是 [6, 6, 6, 6] （而不是 [0, 2, 4, 6]）。

　　这个的原因是 Python 的闭包的后期绑定导致的 late binding，这意味着在闭包中的变量是在内部函数被调用的时候被查找。所以结果是，
  当任何 multipliers() 返回的函数被调用，在那时，i 的值是在它被调用时的周围作用域中查找，到那时，无论哪个返回的函数被调用，
  for 循环都已经完成了，i 最后的值是 3，因此，每个返回的函数 multiplies 的值都是 3。因此一个等于 2 的值被传递进以上代码，
  它们将返回一个值 6 （比如： 3 x 2）。
  
  最普遍的解决方案是创建一个闭包，通过使用默认参数立即绑定它的参数。例如：
	def multipliers():
	  return [lambda x, i=i : i * x for i in range(4)]
    
 39.Python是如何进行内存管理的
 答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制

一、对象的引用计数机制

Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

引用计数增加的情况：

1，一个对象分配一个新名称

2，将其放入一个容器中（如列表、元组或字典）

引用计数减少的情况：

1，使用del语句对对象别名显示的销毁

2，引用超出作用域或被重新赋值

sys.getrefcount( )函数可以获得对象的当前引用计数

多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。

二、垃圾回收

1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。

2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含
一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，
搜索不可访问对象的循环并删除它们。

三、内存池机制

Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。

3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，
用于缓存这些整数的内存就不能再分配给浮点数。


40.面试问题总结
  1.写个快速排序热热身，分析一下复杂度，如果不使用额外的空间，应该怎么写？
  2.说一下Flask中g是怎么实现的，原理是什么？
  3.说一下浏览器从输入url到页面渲染的过程，越详细越好；
  4.了解web安全吗？说一下XSS原理，然后又问了很多；
  5.说一下CSRF的理解；
  6.session和cookie的区别；
  7.数据库的索引，说一下非主键索引是怎么实现的？
  8.十万个人抢100个红包，怎么实现？
  
  
41.可变对象不可变对象区别

42.短 URL 系统是怎么设计的

正确的原理就是通过发号策略，给每一个过来的长地址，发一个号即可，小型系统直接用mysql的自增索引就搞定了。如果是大型应用，可以考虑各种分布式
key-value系统做发号器。不停的自增就行了。第一个使用这个服务的人得到的短地址是http://xx.xx/0 第二个是 http://xx.xx/1 第11个是 http://xx.xx/a 
第依次往后，相当于实现了一个62进制的自增字段即可。几个子问题1. 62进制如何用数据库或者KV存储来做？
其实我们并不需要在存储中用62进制，用10进制就好了。比如第10000个长地址，我们给它的短地址对应的编号是9999，我们通过存储自增拿到9999后，
再做一个10进制到62进制的转换，转成62进制数即可。这个10～62进制转换，你完全都可以自己实现。2. 如何保证同一个长地址，每次转出来都是一样的短地址
上面的发号原理中，是不判断长地址是否已经转过的。也就是说用拿着百度首页地址来转，我给一个http://xx.xx/abc 过一段时间你再来转，我还会给你一个
http://xx.xx/xyz。这看起来挺不好的，但是不好在哪里呢？不好在不是一一对应，而一长对多短。这与我们完美主义的基因不符合，那么除此以外还有什么
不对的地方？
有人说它浪费空间，这是对的。同一个长地址，产生多条短地址记录，这明显是浪费空间的。那么我们如何避免空间浪费，有人非常迅速的回答我，建立一个
长对短的KV存储即可。嗯，听起来有理，但是。。。这个KV存储本身就是浪费大量空间。所以我们是在用空间换空间，而且貌似是在用大空间换小空间。
真的划算吗？这个问题要考虑一下。当然，也不是没有办法解决，我们做不到真正的一一对应，那么打个折扣是不是可以搞定？这个问题的答案太多种，
各有各招，我这就不说了。（由于实在太多人纠结这个问题，请见我最下方的更新）3. 如何保证发号器的大并发高可用
上面设计看起来有一个单点，那就是发号器。如果做成分布式的，那么多节点要保持同步加1，多点同时写入，这个嘛，以CAP理论看，是不可能真正做到的。
其实这个问题的解决非常简单，我们可以退一步考虑，我们是否可以实现两个发号器，一个发单号，一个发双号，这样就变单点为多点了？依次类推，
我们可以实现1000个逻辑发号器，分别发尾号为0到999的号。每发一个号，每个发号器加1000，而不是加1。这些发号器独立工作，互不干扰即可。
而且在实现上，也可以先是逻辑的，真的压力变大了，再拆分成独立的物理机器单元。1000个节点，估计对人类来说应该够用了。如果你真的还想更多，
理论上也是可以的。4. 具体存储如何选择
这个问题就不展开说了，各有各道，主要考察一下对存储的理解。对缓存原理的理解，和对市面上DB、Cache系统可用性，并发能力，一致性等方面的理解。
5. 跳转用301还是302
这也是一个有意思的话题。首先当然考察一个候选人对301和302的理解。浏览器缓存机制的理解。然后是考察他的业务经验。301是永久重定向，
302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。同时对服务器压力也会有一定减少。
但是如果使用了301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。
所以选择302虽然会增加服务器压力，但是我想是一个更好的选择。


43.二分查找

44. 微信红包构架设计


    微信的金额什么时候算？
    答：微信金额是拆的时候实时算出来，不是预先分配的，采用的是纯内存计算，不需要预算空间存储。。
    采取实时计算金额的考虑：预算需要占存储，实时效率很高，预算才效率低。

    实时性：为什么明明抢到红包，点开后发现没有？
    答：2014年的红包一点开就知道金额，分两次操作，先抢到金额，然后再转账。
    2015年的红包的拆和抢是分离的，需要点两次，因此会出现抢到红包了，但点开后告知红包已经被领完的状况。进入到第一个页面不代表抢到，只表示当时红包还有。

    分配：红包里的金额怎么算？为什么出现各个红包金额相差很大？
    答：随机，额度在0.01和剩余平均值*2之间。
    例如：发100块钱，总共10个红包，那么平均值是10块钱一个，那么发出来的红包的额度在0.01元～20元之间波动。
    当前面3个红包总共被领了40块钱时，剩下60块钱，总共7个红包，那么这7个红包的额度在：0.01～（60/7*2）=17.14之间。
    注意：这里的算法是每被抢一个后，剩下的会再次执行上面的这样的算法（Tim老师也觉得上述算法太复杂，不知基于什么样的考虑）。

    这样算下去，会超过最开始的全部金额，因此到了最后面如果不够这么算，那么会采取如下算法：保证剩余用户能拿到最低1分钱即可。

    如果前面的人手气不好，那么后面的余额越多，红包额度也就越多，因此实际概率一样的。

    红包的设计
    答：微信从财付通拉取金额数据郭莱，生成个数/红包类型/金额放到redis集群里，app端将红包ID的请求放入请求队列中，如果发现超过红包的个数，直接返回。根据红包的裸祭处理成功得到令牌请求，则由财付通进行一致性调用，通过像比特币一样，两边保存交易记录，交易后交给第三方服务审计，如果交易过 程中出现不一致就强制回归。

    发性处理：红包如何计算被抢完？
    答：cache会抵抗无效请求，将无效的请求过滤掉，实际进入到后台的量不大。cache记录红包个数，原子操作进行个数递减，到0表示被抢光。财付通按照20万笔每秒入账准备，但实际还不到8万每秒。

    通如何保持8w每秒的写入？
    答：多主sharding，水平扩展机器。

    据容量多少？
    答：一个红包只占一条记录，有效期只有几天，因此不需要太多空间。

    询红包分配，压力大不？
    答：抢到红包的人数和红包都在一条cache记录上，没有太大的查询压力。

    一个红包一个队列？
    答：没有队列，一个红包一条数据，数据上有一个计数器字段。

    有没有从数据上证明每个红包的概率是不是均等？
    答：不是绝对均等，就是一个简单的拍脑袋算法。

    拍脑袋算法，会不会出现两个最佳？
    答：会出现金额一样的，但是手气最佳只有一个，先抢到的那个最佳。

    每领一个红包就更新数据么？
    答：每抢到一个红包，就cas更新剩余金额和红包个数。

    红包如何入库入账？
    数据库会累加已经领取的个数与金额，插入一条领取记录。入账则是后台异步操作。

    入帐出错怎么办？比如红包个数没了，但余额还有？
    答：最后会有一个take all操作。另外还有一个对账来保障。

45.列表推导list comprehension和生成器的优劣

46.面试题集锦
  你知道几种设计模式；
  编码和解码你了解过么；
  列表推导list comprehension和生成器的优劣；
  什么是装饰器；如果想在函数之后进行装饰，应该怎么做；
  手写个使用装饰器实现的单例模式；
  使用装饰器的单例和使用其他方法的单例，在后续使用中，有何区别；
  手写：正则邮箱地址；
  介绍下垃圾回收：引用计数/分代回收/孤立引用环；
  多进程与多线程的区别；CPU密集型适合用什么；
  进程通信的方式有几种；
  介绍下协程，为何比线程还快；
  range和xrange的区别（他妹的我学的py3…）；
  由于我有C/C++背景，因此要求用C来手写：将IP地址字符串（比如“172.0.0.1”）转为32位二进制数的函数。
  算法排序部分

  手写快排；堆排；几种常用排序的算法复杂度是多少；快排平均复杂度多少，最坏情况如何优化；
  手写：已知一个长度n的无序列表，元素均是数字，要求把所有间隔为d的组合找出来，你写的解法算法复杂度多少；
  手写：一个列表A=[A1，A2，…,An]，要求把列表中所有的组合情况打印出来；
  手写：用一行python写出1+2+3+…+10**8 ；
  手写python：用递归的方式判断字符串是否为回文；
  单向链表长度未知，如何判断其中是否有环；
  单向链表如何使用快速排序算法进行排序；
  手写：一个长度n的无序数字元素列表，如何求中位数，如何尽快的估算中位数，你的算法复杂度是多少；
  如何遍历一个内部未知的文件夹（两种树的优先遍历方式）
  网络基础部分

  TCP/IP分别在模型的哪一层；
  socket长连接是什么意思；
  select和epoll你了解么，区别在哪；
  TCP UDP区别；三次握手四次挥手讲一下；
  TIME_WAIT过多是因为什么；
  http一次连接的全过程：你来说下从用户发起request——到用户接收到response；
  http连接方式。get和post的区别，你还了解其他的方式么；
  restful你知道么；
  状态码你知道多少，比如200/403/404/504等等；
  数据库部分

  MySQL锁有几种；死锁是怎么产生的；
  为何，以及如何分区、分表；
  MySQL的char varchar text的区别；
  了解join么，有几种，有何区别，A LEFT JOIN B，查询的结果中，B没有的那部分是如何显示的（NULL）；
  索引类型有几种，BTree索引和hash索引的区别（我没答上来这俩在磁盘结构上的区别）；
  手写：如何对查询命令进行优化；
  NoSQL了解么，和关系数据库的区别；redis有几种常用存储类型；
  Linux部分

  讲一下你常用的Linux/git命令和作用；
  查看当前进程是用什么命令，除了文件相关的操作外，你平时还有什么操作命令；
  （因为我本人Linux本身就很水，只会基本的操作，所以这部分面试官也基本没怎么问。。反正问了就大眼瞪小眼呗）
  django项目部分

  都是让简单的介绍下你在公司的项目，不管是不是后端相关的，主要是要体现出你干了什么；
  你在项目中遇到最难的部分是什么，你是怎么解决的；
  你看过django的admin源码么；看过flask的源码么；你如何理解开源；
  MVC / MTV；
  缓存怎么用；
  中间件是干嘛的；
  CSRF是什么，django是如何避免的；XSS呢；
  如果你来设计login，简单的说一下思路；
  session和cookie的联系与区别；session为什么说是安全的；
  uWSGI和Nginx的作用； 
 
 
 47.python爬虫八道面试题
 1.是否了解线程的同步和异步？

线程同步：多个线程同时访问同一资源，等待资源访问结束，浪费时间，效率低

线程异步：在访问资源时在空闲等待时同时访问其他资源，实现多线程机制

2.是否了解网络的同步和异步？

同步：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

异步: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

3.链表和顺序表储存时各自有什么优点？

（1.顺序表存储

原理：顺序表存储是将数据元素放到一块连续的内存存储空间，存取效率高，速度快。但是不可以动态增加长度

优点：存取速度高效，通过下标来直接存储

缺点：

插入和删除比较慢

不可以增长长度

比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序

（2.链表存储

原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题

优点：插入和删除速度快，保留原有的物理顺序，比如：插入或者删除一个元素时，只需要改变指针指向即可

缺点：查找速度慢，因为查找时，需要循环链表访问

4.使用redis搭建分布式系统时如何处理网络延迟和网络异常？

由于网络异常的存在，分布式系统中请求结果存在“三态”的概念，即三种状态：“成功”、“失败”、“超时（未知）”

当出现“超时”时可以通过发起读取数据的操作以验证 RPC 是否成功（例如银行系统的做法）

另一种简单的做法是，设计分布式协议时将执行步骤设计为可重试的，即具有所谓的“幂等性”

5.数据仓库是什么？

数据仓库是一个面向主题的、集成的、稳定的、反映历史变化的、随着时间的流逝发生变化的数据集合。它主要支持管理人员的决策分析。

数据仓库收集了企业相关内部和外部各个业务系统数据源、归档文件等一系列历史数据，最后转化成企业需要的战略决策信息。

特点：

面向主题：根据业务的不同而进行的内容划分；

集成特性：因为不同的业务源数据具有不同的数据特点，当业务源数据进入到数据仓库时，需要采用统一的编码格式进行数据加载，从而保证数据仓库中数据的唯一性；

非易失性：数据仓库通过保存数据不同历史的各种状态，并不对数据进行任何更新操作。

历史特性：数据保留时间戳字段，记录每个数据在不同时间内的各种状态。

6.你是否了解谷歌的无头浏览器？

无头浏览器即headless browser，是一种没有界面的浏览器。既然是浏览器那么浏览器该有的东西它都应该有，只是看不到界面而已。

Python中selenium模块中的PhantomJS即为无界面浏览器（无头浏览器）:是基于QtWebkit的无头浏览器，

7.你是否了解MySQL数据库的几种引擎？

InnoDB：

InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。

在以下场合下，使用InnoDB是最理想的选择：

更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。

事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。

自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。

外键约束。MySQL支持外键的存储引擎只有InnoDB。

支持自动增加列AUTO_INCREMENT属性。

一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

MEMORY：

使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。

虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。

获得速度的同时也带来了一些缺陷。

一般在以下几种情况下使用Memory存储引擎：

1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。

2.如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。

3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。

8.redis数据库有哪几种数据结构？

5种数据结构

string

使用string时，redis**大多数情况下**并不会理解或者解析其含义，无论使用json、xml还是纯文本在redis看来都是一样的，只是一个字符串，只能进行strlen、append等对字符串通用的操作，无法针对其内容进一步操作。其基本操作命令有set、get、strlen、getrange、append：

在大多数情况之外，就是string中存储的为纯数字的情况，redis可以将字符串当做数字进行进一步操作，这些操作包括decr、decrby、incr、incrby和incrbyfloat。

hash

使用hash时，在我看来，就是value本身就是一组key-value对，不过redis将这里的key称为field（但是hkeys命令为什么不叫hfields命令呢哈哈），也就是value是一组field-value对。其基本操作命令有hset、hget、hmset、hmget、hgetall、hkeys和hdel：

list

使用list时，value就是一个string数组，操作这组string时，可以像对待栈一样使用pop和push操作，但是这个栈两端都能进行操作；也可以像对待数组一样使用一个index参数来操作。list的操作命令略杂，主要分为两类：L开头的和R开头的，L代表LEFT或者LIST，进行一些从列表左端进行的操作，或者一些与端无关的操作；R代表RIGHT，进行一些从列表右端进行的操作。

set

set用于存储一组不重复的值，也可以进行一些集合的操作，就像数学上的集合，它是无序的。基本操作有sadd和sismember：

集合操作有：求交sinter、求并sunion和求差sdiff：

sorted set

sorted set类似set，但是sorted set里每个元素都有一个score，这个score可用于排序和排名。基本操作有zadd、zcount、zrank：

50.面试3

    是否了解django中的manage.py自定义的用法？
    django的常用功能有哪些？
    django有哪些优势？
    是否对django的admin进行定制过？
    在django中有使用过原生sql语句吗？（查了一下可能是涉及到ORM的性能优化）

51.对if __name__ == 'main'的理解陈述

__name__是当前模块名，当模块被直接运行时模块名为__main__，也就是当前的模块，当模块被导入时，模块名就不是__main__，即代码将不会执行。


52.post、get有什么区别？
1. 根据HTTP规范，GET一般用于获取/查询资源信息，应该是安全的和幂等。而POST一般用于更新资源信息2. get是在url中传递数据，数据放在请求头中。
post是在请求体中传递数据3. get传送的数据量较小，只能在请求头上发送数据。post传送的数据量较大，一般被默认为不受限制。5. get安全性非常低，
post安全性较高。但是执行效率却比Post方法好。

建议：1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；

Get 在url中传递数据，数据信息放在请求头中；而post请求信息放在请求体中进行传递数据；get传输数据的数据量较小，只能在请求头中发送数据。

Post传输数据信息比较大，一般不受限制；

Get数据传输安全性低，post传输数据安全性高

在执行效率来说，get比post好

53.http、https协议有什么区别？
https 相对于http 来说对于网页更安全；

http协议是超文本传输协议，被用于在web浏览器和网站服务器之间传递信息。http协议工作是以明文方式发送内容，不提供任何形式的数据加密，而这也是很容易被黑客利用的地方，如果黑客截取了web浏览器和网站服务器之间的传输信息，就可以直接读懂其中的信息，因此http协议不适合传输一些重要的、敏感的信息，比如信用卡密码及支付验证码等。

安全套接字层https协议就是为了解决http协议的这一安全缺陷而出生的，为了数据传输的安全，https在http的基础上加入了ssl协议，ssl依靠证书来验证服务器的身份，为浏览器和服务器之间的通信加密，这样的话即使黑客借去了发送过程中的信息，也无法破解读懂它，我们网站及用户的信息便得到了最大的安全保障。

 

https协议需要到ca申请证书，一般免费证书很少，需要费用。

http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议

http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。

http的连接很简单,是无状态的， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全

http是超文本传输协议，信息明文传输；https是http与ssl加密传输的

http连接的端口应用的是80；https连接的端口应用443

http连接无状态；而https连接是应用http与ssl协议进行连接，可以进行加密传输与身份验证等服务，比http更加安全

54.面试4
3、 域名和IP之间有什么关系，如何查看某个域名对应的所有IP？

 国际互联网(Internet)上有成千百万台主机（host），为了区分这些主机，人们给每台主机都分配了一个专门的“地址”作为标识，称为IP地址

由于IP地址全是些的数字，为了便于用户记忆，Internet上引进了域名服务系统DNS（Domain Name System）。

当您键入某个域名的时候，这个信息首先到达提供此域名解析的服务器上，再将此域名解析为相应网站的IP地址。完成这一任务的过程就称为域名解析。

1.ping  2.nslookup 3.使用站长工具等

在互联网上有成千上万的主机，为了区分这些主机，为每一个主机分配了IP,而IP全是数字，为了方便人们记忆，生成了域名，

Ping;站长工具

4、 http协议头中，keep-alive字段有什么作用？

 HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；

当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。

 

5、 robots协议是什么？

 Robots协议（也称为爬虫协议、爬虫规则、机器人协议等）也就是robots.txt，网站通过robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。

Robots协议是网站国际互联网界通行的道德规范，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。因其不是命令，故需要搜索引擎自觉遵守。

 

6、 列出几种常见的关系型数据库和非关系型数据库？（每种至少两个）

 mysql,oracle  mongoDB,redis

Oracle、Mysql、SQLServer、DB2           Redis MongoDB Cassandra

 

7、 内存泄露是什么？如何避免？

 指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。

内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

导致程序运行速度减慢甚至系统崩溃等严重后果。

 

有 __del__() 函数的对象间的循环引用是导致内存泄漏的主凶。

 

不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题.

通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息

可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存泄漏

 

Python的内存管理机制1.引用计数：通过引用计数来保持对内存中的变量跟踪，Python内部记录中所有在使用对象各有多少个引用。

Python中有个内部跟踪变量叫做引用计数器，每个变量有多少个引用，简称引用计数。当对象被创建时就创建了一个引用计数。

当某个对象的引用计数为0时，对象就不在需要，就列入了垃圾回收队列。

引用计数增加：1.对象被创建：x=4;2.另外的别人被创建：y=x;3.被作为参数传递给函数：foo(x);4.作为容器对象的一个元素：a=[1,x,'33'];

引用计数减少时：1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1;

                2.对象的别名被显式的销毁：del x ；或者del y;

                3.对象的一个别名被赋值给其他对象：x=789

                4.对象从一个窗口对象中移除：myList.remove(x)

                5.窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域。

2.垃圾回收1.引用计数： 每个对象中都有ob-refcnt来做引用计数。当一个对象...,ob-refcnt就会增加，当引用的对象删除，那么ob-refcnt就会减少当ob-refcnt为零，就会释放该对象的内存空间2.标记清除： 解决循环引用的问题。先按需分配，等到没有空闲内存的时候，从寄存器和程序栈上的引用出发，遍历所有对象和引用把所有能访问的打标记，最后将没有标记的对象释放掉3.分代技术： 提高效率，提高垃圾回收的效率，按照存活时间，分成不同的集合。将内存块按照其存活时间划分为不同的集合。每个集合就称为一个“代”，垃圾回收的频率随代的存活时间增大而减小。。Python默认定义分代对象集合，引用数越大，对象的存活时间越长

3.内存池机制

在Python中，大多数申请的都是小块的内存，会执行大量的malloc和free操作。Python引入了一个内存池机制，用于管理对小块内存的申请和释放，即Pymalloc机制。

它将不用的内存放到内存池而不是返回给操作系统。1. 当申请的内存小于256字节时，PyObject_Malloc会在内存池中申请内存；当申请的内存大于256字节时，PyObject_Malloc的行为将蜕化为malloc的行为。当然，通过修改Python源代码，我们可以改变这个默认值，从而改变Python的默认内存管理行为。2. 对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

 

8、 列举几个常用的dom解析项目、插件

 xpath，xml

xml、libxml2 、lxml 、xpath

 

9、 常见的反爬虫机制有哪些？

 爬取过程中，生成多个headers，伪造;

通过headers反爬虫：解决策略，伪造headers

基于用户行为反爬虫：动态变化去爬取数据，模拟普通用户的行为

基于动态页面的反爬虫：跟踪服务器发送的ajax请求，模拟ajax请求

动态爬取数据，模仿用户行为；

1. 伪装user agent

2.使用代理

3. 降低访问频率

4. 动态爬取数据，模拟用户行为；或通过ajax请求进行模拟。

10、如何提高爬取效率？

 爬虫下载慢主要原因是阻塞等待发往网站的请求和网站返回；

1. 爬取方面，利用异步io。2.处理方面，利用消息队列做生产者消费者模型

1. 采用异步与多线程，扩大，电脑的cpu利用率；

2. 采用消息队列模式

3. 提高带宽

 

1、楼梯问题

1.1、给一个楼梯，从最下面往上走，每次可以走1到n步，求总共有多少种走法？

1.2、给一个楼梯，从最下面往上走，每次可以走1步或2步，求总共有多少种走法？

1.3、给一个楼梯，从最下面往上走，每次可以走1步或2步或3步，求总共有多少种走法？

 # 1、 给一个楼梯，从最下面往上走，每次可以走1或2步，求总共有多少种走法？

# 假设只有一个台阶，那么只有一种跳法，那就是一次跳一级，f(1)=1；如果有两个台阶，那么有两种跳法，第一种跳法是一次跳一级，第二种跳法是一次跳两级,f(2)=2。

# 如果有大于2级的n级台阶，那么假如第一次跳一级台阶，剩下还有n-1级台阶，有f(n-1)种跳法，假如第一次条2级台阶，剩下n-2级台阶，有f(n-2)种跳法。这就表示f(n)=f(n-1)+f(n-2)。def walk_stairs(stairs):

    if stairs == 1:

        return 1

    if stairs == 2:

        return 2

    else:

        return walk_stairs(stairs-1) + walk_stairs(stairs-2)

# 2、给一个楼梯，从最下面往上走，每次可以走1到n步，求总共有多少种走法？

# 上1个台阶 1

# 上2个台阶 2

# 上3个台阶 4

# 上4个台阶 8

# 上n个台阶 2^(n-1)

# 3、给一个楼梯，从最下面往上走，每次可以走1步或2步或3步，求总共有多少种走法？

# 上1个台阶 2^(1-1)

# 上2个台阶 2^(2-1)

# 上3个台阶 2^(3-1)

# f(n) = f(n-1) + f(n-2) + f(n-3)

 

2、 给一个字符数组，字符包含a-z、1-9，比如：a b c 4 b 2 a c 1 1 3，求只出现一次的第一次出现的字符

 str_list = ['a', 'b', 'c', 4, 'b', 2, 'a', 'c', 1, 1, 3]

def find_only_one(alist):

    for string in alist:

        count = alist.count(string)

        if count == 1:

            return string

    return None

 

3、 有一个html文本字符串，让我取出<a href="提示我这个链接地址">sflkj</a>这个a标签里面的href的链接地址？

from bs4 import BeautifulSoup

text = "<a href='提示我这个链接地址'>sflkj</a>"

the_html = BeautifulSoup(text,features='lxml')

print(the_html.find('a').attrs['href'])

或：from lxml import etree

Html = "<a href='提示我这个链接地址'>sflkj</a>".content.decode()

Html = etree.Html(Html)

li_temp_list = Html.xpath("//a/@href")

4、 下面是一个单线程的代码，请改写成多线程的：

start = "http://google.com"

queue = [start]

visited = {start}

while queue:

    url = queue.pop(0)

    print(url)  

    for next_url in extract_url(url):

        if next_url not in visited:

            queue.append(next_url)

        visited.add(next_url)

-----------------------------------------

 from concurrent.futures import ThreadPoolExecutor

start = "http://google.com"

queue = [start]

visited = {start}

pool = ThreadPoolExecutor(10)

def func(url):

    for next_url in extract_url(url):

        if next_url not in visited:

            queue.append(next_url)

        visited.add(next_url)

while queue:

    url = queue.pop(0)

    pool.submit(func,url)

pool.shutdown(wait=True)


55.1、tcp和udp的区别？

　　TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。

　　TCP三次握手过程：
　　1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段，主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.
　　2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我
　　3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了这样3次握手就完成了,主机A和主机B 就可以传输数据了.

　　3次握手的特点：
　　没有应用层的数据
　　SYN这个标志位只有在TCP建产连接时才会被置1
　　握手完成后SYN标志位被置0

　　TCP建立连接要进行3次握手,而断开连接要进行4次：
　　1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
　　2  主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
　　3 由B 端再提出反方向的关闭请求,将FIN置1
　　4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
　　由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础。

　　名词解释：
　　ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.
　　SYN  同步序列号,TCP建立连接时将这个位置1
　　FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1

　　TCP的包头结构：
　　源端口 16位
　　目标端口 16位
　　序列号 32位
　　回应序号 32位
　　TCP头长度 4位
　　reserved 6位
　　控制代码 6位
　　窗口大小 16位
　　偏移量 16位
　　校验和 16位
　　选项  32位(可选)
　　这样我们得出了TCP包头的最小长度，为20字节。

　　UDP（User Data Protocol，用户数据报协议）
　　（1） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
　　（2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。
　　（3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
　　（4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
　　（5）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
　　（6）UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。
　　我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。
　　UDP的包头结构：
　　源端口 16位
　　目的端口 16位
　　长度 16位
　　校验和 16位

　　小结TCP与UDP的区别：
　　1.基于连接与无连接；
　　2.对系统资源的要求（TCP较多，UDP少）；
　　3.UDP程序结构较简单；
　　4.流模式与数据报模式 ；
　　5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

2、对内存中栈和堆的了解？
　　栈：
       什么是栈，它是你的电脑内存的一个特别区域，它用来存储被每一个function（包括mian（）方法）创建的临时变量。栈是FILO，就是先进后出原则的结构体，它密切的被CPU管理和充分利用。每次function声明一个新的变量，它就会被“推”到栈中。然后每次一个function退出时，所有关于这个函数中定义的变量都会被释放（换句话说就是删除）。一旦栈中的变量释放，这块区域就会变成可用的，提供给其他栈中的变量。
       用栈存储变量的好处是，内存是被你管理的。你不用手动的创建内存，不用当你不在需要它的时候手动释放内存。另外，由于CPU组织栈内存很高效。读出和写入栈变量是很快的。
      理解栈的关键是理解概念，当一个function退出时，所有它的变量都会从栈中弹出,以后都会永远消失。因此栈中的变量本质是局部的。这和我们原来理解为变量作用域或者本地或者全局变量是相关的。在C中，一个公共的bug 是从你程序中的一个function外尝试访问一个在栈中的这个function的变量（在该function已经退出后）。
     关于栈的另一个特点我们应该记住，就是存储在栈中的变量的大小有限制。而堆上创建变量不用考虑。
     总结栈：
      a、栈的伸长和伸缩就是函数压入或者推出局部变量。
      b、我们不用自己去管理内存，变量创建和释放都是自动的。
      c、栈中的变量只有在函数创建运行时存在。
　　堆：
       堆也是我们的计算机内存中的一个区域，但是他不是自动管理的。而且也不是被CPU密切的管理着。它是一片更加自由的内存区域（很大）。要想在堆上创建内存，我们必须使用malloc() 或者calloc（），他们都是C语言编译的。一旦你在堆上分配内存，当你不在需要的时候你必须用free()去销毁。如果你不销毁或者销毁失败，你的程序就会有内存泄露。换句话说就是堆内存会一直在，其他进程无法使用。
     不像栈，堆没有变量大小的限制（除了你电脑的物理限制条件外）。堆内存读出和写入都比较慢，因为它必须使用指针图访问堆内存。
　　栈和堆的优缺点：
     　栈：
          a、快速访问。
          b、没有必要明确的创建分类变量，因为它是自动管理的。
          c、空间被CPU高效地管理着，内存不会变成碎片。
          d、只有局部变量
          e、受限于栈大小(取决于操作系统)
          f、变量不能调整大小。
        堆：
          a、变量可以被全局访问
          b、没有内存大小限制
          c、（相对）访问比较慢
          d、没有高效地使用空间，随着块内存的创建和销毁，内存可能会变成碎片。
          e、你必须管理内存（变量的创建和销毁你必须要负责）
          f、变量大小可以用realloc( )调整
 
3、爬虫框架scrapy的工作流程
　　a、spider解析下载器下下来的response，返回item或是links
　　b、item或者link经过spidermiddleware的process_spider_out( )方法，交给engine
　　c、engine将item交给item pipeline ，将links交给调度器
　　d、在调度器中，先将requests对象利用scrapy内置的指纹函数生成一个指纹对象
　　e、如果requests对象中的don't filter参数设置为False，并且该requests对象的指纹不在信息指纹的队列中，那么就把该request对象放到优先级队列中
　　f、从优先级队列中获取request对象，交给engine
　　g、engine将request对象交给下载器下载，期间会通过downloadmiddleware的process_request方法
　　h、下载器完成下载，获得response对象，将该对象交给engine，期间会经过downloadmiddleware的process_response（ ）方法
　　i、engine将获得的response对象交给spider进行解析，期间会经过spidermiddleware的process_spider_input()的方法
　　j、从a开始循环
 
4、字典、列表查询时的时间复杂度是怎样的？　　

　　列表是序列，可以理解为数据结构中的数组，字典可以理解为数据结构中的hashmap，python中list对象的存储结构采用的是线性表，因此其查询复杂度为O(n),而dict对象的存储结构采用的是散列表(hash表)，其在最优情况下查询复杂度为O(1)。dict的占用内存稍比list大，会在1.5倍左右。

5、递归中如果没有终止条件会怎样？

　　概念：递归算法是一种直接或者间接的调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的。

　　特点：

　　①递归就是在过程或者函数里调用自身。

　　②在使用递归策略时，必须有一个明确的递归条件，称为递归出口。

　　③递归算法解题通常显得很简洁，但递归算法解题的效率较低。所以一般不倡导使用递归算法设计程序。

　　④在递归调用的过程当中系统的每一层的返回点、局部变量等开辟了栈来存储。递归函数次数过多容易造成栈溢出等。 所以一般不倡导用递归算法设计程序

　　递归如果没有终止条件会导致递归调用成为死循环而不能正常结束，并且会造成栈溢出

笔试

　　1、去除列表中的重复元素
复制代码

def distinct_list(list):
    d_l = []
    for i in list:
        if i not in d_l:
            d_l.append(i)
    return d_l

复制代码

　　2、得到列表的一个子列表，该列表满足列表中的元素在原列表中是连续的，且子列表的所有元素之和最大。例如[1, -2, 3, -1, 2] => [3, -1, 2]

1、多线程和多进程有什么区别？

　　线程：

　　线程是操作系统能够进行运算调度的最小单位（程序执行流的最小单元）。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

　　一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机;运行状态是指线程占有处理机正在运行;阻塞状态是指线程在等待一个事件(如某个信号量)，逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。

　　线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。

　　进程：

　　进程由至少一个线程组成。进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体;在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。里面包含对各种资源的调用，内存的管理，网络接口的调用等。。。对各种资源管理的集合 就可以称为 进程

　　区别：

　　（1）线程共享内存空间；进程的内存是独立的

　　（2）同一个进程的线程之间可以直接交流；两个进程想通信，必须通过一个中间代理来实现

　　（3）创建新线程很简单； 创建新进程需要对其父进程进行一次克隆

　　（4）一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程

　　（5）改变主线程（如优先权），可能会影响其它线程；改变父进程，不影响子进程　　

2、http请求的header包含哪些信息？

　　包含：user-agent、referer、cookie、host、Cache-Control等。

3、爬取的内容怎么去重？

　　利用数据库，根据信息的特定字段去重。

 

笔试

　　1、计算n的阶乘，不要使用递归

def factorial(n):
    x = 1
    for i in range(1, n+1):
        x = x * i
    return x

　　2、用正则匹配手机号码

re.compile(r'1[3578]\d{9}')


56.数据库面试
mysql索引种类和原理, B+树, 联合索引, 索引覆盖, 事物级别, 并发事物, MVCC

根据问题写sql语句或设计表结构

Redis数据类型, 跳表原理, 一致性哈希

　二、操作系统

　　可以直接认为是linux，毕竟搞后端的多数是和linux打交道。

　　1.tcp/udp的区别?tcp粘包是怎么回事，如何处理?udp有粘包吗?

　　2.time_wait是什么情况?出现过多的close_wait可能是什么原因? 3.epoll,select的区别?边缘触发，水平触发区别?

三、存储

　　存储可能包含rdbms，nosql以及缓存等，我以mysql,redis举例mysql相关

　　1.谈谈mysql字符集和排序规则?

　　2.varchar与char的区别是什么?大小限制?

　　3.primary key和unique的区别?

　　4.外键有什么用，是否该用外键?外键一定需要索引吗?

四、安全

　　1.sql注入是怎么产生的，如何防止?

　　2.xss如何预防?htmlescape后能否避免xss?

　　3.csrf是什么?django是如何防范的?
  
  说一下对浏览器缓存的理解；
说一下MySQL优化；
说一下redis；
说一下从输入url到返回都发生了什么；
域名怎么解析的


    编程实现翻转单链表；
    MySQL中varchar和char的区别；
    HTTP协议常用的状态码；
    对Redis的了解；
    GIL；
    对加密的了解；



    设计一个类似滴滴打车优惠券的系统，尽可能详细，包括接口、数据表等；
    斐波那契数列，打印出所有可能的结果（不是最终结果）；
    MySQL索引设计；
    MySQL锁的理解；
    M有SQL的分区和分表；


    装饰器相关问题，原理、使用、切面编程等；
    编程实现顺序数组错位后的查找；
    按照简历一条一条往下问；
    Linux对内存进行操作的命令；

python判断当前用户是否是root
import os
if os.geteuid() != 0:
  print "This program must be run as root. Aborting."
sys.exit(1) 

python代码得到列表list的交集与差集
交集
b1=[1,2,3]
b2=[2,3,4]
b3 = [val for val in b1 if val in b2]
print b3

差集

b1=[1,2,3]
b2=[2,3,4]
b3 = [val for val in b1 if val not in b2]
print b3

差集实例
———-
#/bin/env python
# -*- coding:utf-8 -*-

f = open(‘C:\diff_dealer\excel.txt’)
excel = f.readlines()
f.close()

f= open(‘C:\diff_dealer\db.txt’)
db = f.readlines()
diff = [val for val in db if val not in excel]
f.close()

f = open(‘C:\diff_dealer\diff.txt’, ‘w’)
f.writelines(diff)
f.close()

print diff

2 Python中的元类(metaclass)

这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看：《深刻理解Python中的元类(metaclass)》
3 @staticmethod和@classmethod

Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:
Python
def foo(x):
    print "executing foo(%s)"%(x)

class A(object):
    def foo(self,x):
        print "executing foo(%s,%s)"%(self,x)

    @classmethod
    def class_foo(cls,x):
        print "executing class_foo(%s,%s)"%(cls,x)

    @staticmethod
    def static_foo(x):
        print "executing static_foo(%s)"%x

a=A()
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
	
def foo(x):
    print "executing foo(%s)"%(x)
 
class A(object):
    def foo(self,x):
        print "executing foo(%s,%s)"%(self,x)
 
    @classmethod
    def class_foo(cls,x):
        print "executing class_foo(%s,%s)"%(cls,x)
 
    @staticmethod
    def static_foo(x):
        print "executing static_foo(%s)"%x
 
a=A()

这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用foo(x),这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.

对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用.
\ 	实例方法 	类方法 	静态方法
a = A() 	a.foo(x) 	a.class_foo(x) 	a.static_foo(x)
A 	不可用 	A.class_foo(x) 	A.static_foo(x)

更多关于这个问题:http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python
4 类变量和实例变量

Python
class Person:
    name="aaa"

p1=Person()
p2=Person()
p1.name="bbb"
print p1.name  # bbb
print p2.name  # aaa
print Person.name  # aaa
1
2
3
4
5
6
7
8
9
	
class Person:
    name="aaa"
 
p1=Person()
p2=Person()
p1.name="bbb"
print p1.name  # bbb
print p2.name  # aaa
print Person.name  # aaa

类变量就是供类使用的变量,实例变量就是供实例使用的.

这里p1.name="bbb"是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,p1.name一开始是指向的类变量name="aaa",但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.

可以看看下面的例子:
Python
class Person:
    name=[]

p1=Person()
p2=Person()
p1.name.append(1)
print p1.name  # [1]
print p2.name  # [1]
print Person.name  # [1]
1
2
3
4
5
6
7
8
9
	
class Person:
    name=[]
 
p1=Person()
p2=Person()
p1.name.append(1)
print p1.name  # [1]
print p2.name  # [1]
print Person.name  # [1]

参考:http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block
5 Python自省

这个也是python彪悍的特性.

自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
6 字典推导式

可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:
Python
d = {key: value for (key, value) in iterable}
1
	
d = {key: value for (key, value) in iterable}

7 Python中单下划线和双下划线

Python
>>> class MyClass():
...     def __init__(self):
...             self.__superprivate = "Hello"
...             self._semiprivate = ", world!"
...
>>> mc = MyClass()
>>> print mc.__superprivate
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: myClass instance has no attribute '__superprivate'
>>> print mc._semiprivate
, world!
>>> print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
	
>>> class MyClass():
...     def __init__(self):
...             self.__superprivate = "Hello"
...             self._semiprivate = ", world!"
...
>>> mc = MyClass()
>>> print mc.__superprivate
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: myClass instance has no attribute '__superprivate'
>>> print mc._semiprivate
, world!
>>> print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}

__foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.

_foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.

__foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名.

详情见:http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python

或者: http://www.zhihu.com/question/19754941
8 字符串格式化:%和.format

.format在许多方面看起来更便利.对于%最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:
Python
"hi there %s" % name
1
	
"hi there %s" % name

但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:
Python
"hi there %s" % (name,)   # 提供一个单元素的数组而不是一个参数
1
	
"hi there %s" % (name,)   # 提供一个单元素的数组而不是一个参数

但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.

你为什么不用它?

    不知道它(在读这个之前)
    为了和Python2.5兼容(譬如logging库建议使用%(issue #4))

http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format
9 迭代器和生成器

这个是stackoverflow里python排名第一的问题,值得一看: http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python

这是中文版: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html
10 *args and **kwargs

用*args和**kwargs只是为了方便并没有强制使用它们.

当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数:
Python
>>> def print_everything(*args):
        for count, thing in enumerate(args):
...         print '{0}. {1}'.format(count, thing)
...
>>> print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage
1
2
3
4
5
6
7
8
	
>>> def print_everything(*args):
        for count, thing in enumerate(args):
...         print '{0}. {1}'.format(count, thing)
...
>>> print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage

相似的,**kwargs允许你使用没有事先定义的参数名:
Python
>>> def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print '{0} = {1}'.format(name, value)
...
>>> table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit
1
2
3
4
5
6
7
	
>>> def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print '{0} = {1}'.format(name, value)
...
>>> table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit

你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如:
Python
def table_things(titlestring, **kwargs)
1
	
def table_things(titlestring, **kwargs)

*args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面.

当调用函数时你也可以用*和**语法.例如:
Python
>>> def print_three_things(a, b, c):
...     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)
...
>>> mylist = ['aardvark', 'baboon', 'cat']
>>> print_three_things(*mylist)

a = aardvark, b = baboon, c = cat
1
2
3
4
5
6
7
	
>>> def print_three_things(a, b, c):
...     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)
...
>>> mylist = ['aardvark', 'baboon', 'cat']
>>> print_three_things(*mylist)
 
a = aardvark, b = baboon, c = cat

就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.

http://stackoverflow.com/questions/3394835/args-and-kwargs
11 面向切面编程AOP和装饰器

这个AOP一听起来有点懵,同学面阿里的时候就被问懵了…

装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

这个问题比较大,推荐: http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python

中文: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html
12 鸭子类型

“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。

比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。

又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.

鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。
13 Python中重载

引自知乎:http://www.zhihu.com/question/20053359

函数重载主要是为了解决两个问题。

    可变参数类型。
    可变参数个数。

另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。

好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。

那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。

好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。
14 新式类和旧式类

这个面试官问了,我说了老半天,不知道他问的真正意图是什么.

stackoverflow

这篇文章很好的介绍了新式类的特性: http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html

新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),<Python核心编程>里讲的也很多.
15 __new__和__init__的区别

这个__new__确实很少见到,先做了解吧.

    __new__是一个静态方法,而__init__是一个实例方法.
    __new__方法会返回一个创建的实例,而__init__什么都不返回.
    只有在__new__返回一个cls的实例时后面的__init__才能被调用.
    当创建一个新实例时调用__new__,初始化一个实例时用__init__.

stackoverflow

ps: __metaclass__是创建类时起作用.所以我们可以分别使用__metaclass__,__new__和__init__来分别在类创建,实例创建和实例初始化的时候做一些小手脚.
16 单例模式

这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.
1 使用__new__方法

Python
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1
1
2
3
4
5
6
7
8
9
	
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance
 
class MyClass(Singleton):
    a = 1

2 共享属性

创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法.
Python
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1
1
2
3
4
5
6
7
8
9
	
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob
 
class MyClass2(Borg):
    a = 1

3 装饰器版本

Python
def singleton(cls, *args, **kw):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass:
  ...
1
2
3
4
5
6
7
8
9
10
11
	
def singleton(cls, *args, **kw):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance
 
@singleton
class MyClass:
  ...

4 import方法

作为python的模块是天然的单例模式
Python
# mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()

# to use
from mysingleton import my_singleton

my_singleton.foo()
1
2
3
4
5
6
7
8
9
10
11
	
# mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass
 
my_singleton = My_Singleton()
 
# to use
from mysingleton import my_singleton
 
my_singleton.foo()

17 Python中的作用域

Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。

当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：

本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）
18 GIL线程全局锁

线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.

见Python 最难的问题

解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).
19 协程

知乎被问到了,呵呵哒,跪了

简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.

Python里最常见的yield就是协程的思想!可以查看第九个问题.
20 闭包

闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。

当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:

    必须有一个内嵌函数
    内嵌函数必须引用外部函数中的变量
    外部函数的返回值必须是内嵌函数

感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.

重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.

闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.
21 lambda函数

其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.

推荐: 知乎
22 Python函数式编程

这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.

推荐: 酷壳

python中函数式编程支持:

filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。
Python
>>>a = [1,2,3,4,5,6,7]
>>>b = filter(lambda x: x > 5, a)
>>>print b
>>>[6,7]
1
2
3
4
	
>>>a = [1,2,3,4,5,6,7]
>>>b = filter(lambda x: x > 5, a)
>>>print b
>>>[6,7]

map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：
Python
>>> a = map(lambda x:x*2,[1,2,3])
>>> list(a)
[2, 4, 6]
1
2
3
	
>>> a = map(lambda x:x*2,[1,2,3])
>>> list(a)
[2, 4, 6]

reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：
Python
>>> reduce(lambda x,y:x*y,range(1,4))
6
1
2
	
>>> reduce(lambda x,y:x*y,range(1,4))
6

23 Python里的拷贝

引用和copy(),deepcopy()的区别
Python
import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append('c')  #修改对象a中的['a', 'b']数组对象

print 'a = ', a
print 'b = ', b
print 'c = ', c
print 'd = ', d

输出结果：
a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
c =  [1, 2, 3, 4, ['a', 'b', 'c']]
d =  [1, 2, 3, 4, ['a', 'b']]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
	
import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象
 
b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝
 
a.append(5)  #修改对象a
a[4].append('c')  #修改对象a中的['a', 'b']数组对象
 
print 'a = ', a
print 'b = ', b
print 'c = ', c
print 'd = ', d
 
输出结果：
a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
c =  [1, 2, 3, 4, ['a', 'b', 'c']]
d =  [1, 2, 3, 4, ['a', 'b']]

24 Python垃圾回收机制

Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。
1 引用计数

PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。

优点:

    简单
    实时性

缺点:

    维护引用计数消耗资源
    循环引用

2 标记-清除机制

基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。
3 分代技术

分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

举例：
当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。
25 Python的List

推荐: http://www.jianshu.com/p/J4U6rR
26 Python的is

is是对比地址,==是对比值
27 read,readline和readlines

    read 读取整个文件
    readline 读取下一行,使用生成器方法
    readlines 读取整个文件到一个迭代器以供我们遍历

28 Python2和3的区别

推荐：《Python 2.7.x 和 3.x 版本的重要区别》
操作系统
1 select,poll和epoll

其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.

这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.

selec,poll和epoll区别总结

基本上select有3个缺点:

    连接数受限
    查找配对速度慢
    数据由内核拷贝到用户态

poll改善了第一个缺点

epoll改了三个缺点.

关于epoll的: http://www.cnblogs.com/my_life/articles/3968782.html
2 调度算法

    先来先服务(FCFS, First Come First Serve)
    短作业优先(SJF, Shortest Job First)
    最高优先权调度(Priority Scheduling)
    时间片轮转(RR, Round Robin)
    多级反馈队列调度(multilevel feedback queue scheduling)

实时调度算法:

    最早截至时间优先 EDF
    最低松弛度优先 LLF

3 死锁

原因:

    竞争资源
    程序推进顺序不当

必要条件:

    互斥条件
    请求和保持条件
    不剥夺条件
    环路等待条件

处理死锁基本方法:

    预防死锁(摒弃除1以外的条件)
    避免死锁(银行家算法)
    检测死锁(资源分配图)
    解除死锁
        剥夺资源
        撤销进程

4 程序编译与链接

推荐: http://www.ruanyifeng.com/blog/2014/11/compiler.html

Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)

以c语言为例:
1 预处理

预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：

    将所有的“#define”删除，并展开所用的宏定义
    处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”
    处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的
    删除所有注释
    添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号
    保留所有的#pragma编译器指令。

2 编译

编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。
3 汇编

汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)
4 链接

链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。
链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。
5 静态链接和动态链接

静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来
静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库

动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序
6 虚拟内存技术

虚拟存储器是值具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.
7 分页和分段

分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。

分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。
分页与分段的主要区别

    页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.
    页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.
    分页的作业地址空间是一维的.分段的地址空间是二维的.

8 页面置换算法

    最佳置换算法OPT:不可能实现
    先进先出FIFO
    最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.
    clock算法

9 边沿触发和水平触发

边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件
数据库
1 事务

数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。
2 数据库索引

推荐: http://tech.meituan.com/mysql-index.html

MySQL索引背后的数据结构及算法原理

聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理
3 Redis原理
4 乐观锁和悲观锁

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
5 MVCC
6 MyISAM和InnoDB

MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。

InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。
网络
1 三次握手

    客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。
    服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
    最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。

2 四次挥手
3 ARP协议

地址解析协议(Address Resolution Protocol): 根据IP地址获取物理地址的一个TCP/IP协议
4 urllib和urllib2的区别

这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.

    urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。
    urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。

5 Post和Get

GET和POST有什么区别？及为什么网上的多数答案都是错的

get: RFC 2616 – Hypertext Transfer Protocol — HTTP/1.1
post: RFC 2616 – Hypertext Transfer Protocol — HTTP/1.1
6 Cookie和Session
	Cookie 	Session
储存位置 	客户端 	服务器端
目的 	跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 	跟踪会话
安全性 	不安全 	安全

session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。
7 apache和nginx的区别

nginx 相对 apache 的优点：

    轻量级，同样起web 服务，比apache 占用更少的内存及资源
    抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能
    配置简洁
    高度模块化的设计，编写模块相对简单
    社区活跃

apache 相对nginx 的优点：

    rewrite ，比nginx 的rewrite 强大
    模块超多，基本想到的都可以找到
    少bug ，nginx 的bug 相对较多
    超稳定

8 网站用户密码保存

    明文保存
    明文hash后保存,如md5
    MD5+Salt方式,这个salt可以随机
    知乎使用了Bcrypy(好像)加密

9 HTTP和HTTPS
状态码 	定义
1xx 报告 	接收到请求，继续进程
2xx 成功 	步骤成功接收，被理解，并被接受
3xx 重定向 	为了完成请求,必须采取进一步措施
4xx 客户端出错 	请求包括错的顺序或不能完成
5xx 服务器出错 	服务器无法完成显然有效的请求

403: Forbidden
404: Not Found

HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA
10 XSRF和XSS

    CSRF(Cross-site request forgery)跨站请求伪造
    XSS(Cross Site Scripting)跨站脚本攻击

CSRF重点在请求,XSS重点在脚本
11 幂等 Idempotence

HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用)

GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。

POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。

PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。
12 RESTful架构(SOAP,RPC)

推荐: http://www.ruanyifeng.com/blog/2011/09/restful.html
13 SOAP

SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。
14 RPC

RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.

进化的顺序: RPC -> SOAP -> RESTful
15 CGI和WSGI

CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。
CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。

WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。

官方说明：PEP-3333
16 中间人攻击

在GFW里屡见不鲜的,呵呵.

中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。
17 c10k问题

所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。
推荐: http://www.kegel.com/c10k.html
18 socket

推荐: http://www.cnblogs.com/bingyun84/archive/2009/10/16/1584387.html

Socket=Ip address+ TCP/UDP + port
19 浏览器缓存

推荐: http://web.jobbole.com/84367/

304 Not Modified
20 HTTP1.0和HTTP1.1

推荐: http://blog.csdn.net/elifefly/article/details/3964766

    请求头Host字段,一个服务器多个网站
    长链接
    文件断点续传
    身份认证,状态管理,Cache缓存

21 Ajax

AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。
*NIX
unix进程间通信方式(IPC)

    管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
    命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
    信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
    消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺
    共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
    内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
    信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
    套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

数据结构
1 红黑树

红黑树与AVL的比较：

AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；

红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；

所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。
编程题
1 台阶问题/斐波纳挈

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
Python
fib = lambda n: n if n <= 2 else fib(n - 1) + fib(n - 2)
1
	
fib = lambda n: n if n <= 2 else fib(n - 1) + fib(n - 2)

第二种记忆方法
Python
def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap


@ memo
def fib(i):
    if i < 2:
        return 1
    return fib(i-1) + fib(i-2)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
	
def memo(func):
    cache = {}
    def wrap(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrap
 
 
@ memo
def fib(i):
    if i < 2:
        return 1
    return fib(i-1) + fib(i-2)

第三种方法
Python
def fib(n):
    a, b = 0, 1
    for _ in xrange(n):
        a, b = b, a + b
    return b
1
2
3
4
5
	
def fib(n):
    a, b = 0, 1
    for _ in xrange(n):
        a, b = b, a + b
    return b

2 变态台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
Python
fib = lambda n: n if n < 2 else 2 * fib(n - 1)
1
	
fib = lambda n: n if n < 2 else 2 * fib(n - 1)

3 矩形覆盖

我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

    第2*n个矩形的覆盖方法等于第2*(n-1)加上第2*(n-2)的方法。

Python
f = lambda n: 1 if n < 2 else f(n - 1) + f(n - 2)
1
	
f = lambda n: 1 if n < 2 else f(n - 1) + f(n - 2)

4 杨氏矩阵查找

在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
5 去除列表中的重复元素

用集合
Python
list(set(l))
1
	
list(set(l))

用字典
Python
l1 = ['b','c','d','b','c','a','a']
l2 = {}.fromkeys(l1).keys()
print l2
1
2
3
	
l1 = ['b','c','d','b','c','a','a']
l2 = {}.fromkeys(l1).keys()
print l2

用字典并保持顺序
Python
l1 = ['b','c','d','b','c','a','a']
l2 = list(set(l1))
l2.sort(key=l1.index)
print l2
1
2
3
4
	
l1 = ['b','c','d','b','c','a','a']
l2 = list(set(l1))
l2.sort(key=l1.index)
print l2

列表推导式
Python
l1 = ['b','c','d','b','c','a','a']
l2 = []
[l2.append(i) for i in l1 if not i in l2]
1
2
3
	
l1 = ['b','c','d','b','c','a','a']
l2 = []
[l2.append(i) for i in l1 if not i in l2]

面试官提到的,先排序然后删除.
6 链表成对调换

1->2->3->4转换成2->1->4->3.
Python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    # @param a ListNode
    # @return a ListNode
    def swapPairs(self, head):
        if head != None and head.next != None:
            next = head.next
            head.next = self.swapPairs(next.next)
            next.next = head
            return next
        return head
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
	
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
 
class Solution:
    # @param a ListNode
    # @return a ListNode
    def swapPairs(self, head):
        if head != None and head.next != None:
            next = head.next
            head.next = self.swapPairs(next.next)
            next.next = head
            return next
        return head

7 创建字典的方法
1 直接创建

Python
dict = {'name':'earth', 'port':'80'}
1
	
dict = {'name':'earth', 'port':'80'}

2 工厂方法

Python
items=[('name','earth'),('port','80')]
dict2=dict(items)
dict1=dict((['name','earth'],['port','80']))
1
2
3
	
items=[('name','earth'),('port','80')]
dict2=dict(items)
dict1=dict((['name','earth'],['port','80']))

3 fromkeys()方法

Python
dict1={}.fromkeys(('x','y'),-1)
dict={'x':-1,'y':-1}
dict2={}.fromkeys(('x','y'))
dict2={'x':None, 'y':None}
1
2
3
4
	
dict1={}.fromkeys(('x','y'),-1)
dict={'x':-1,'y':-1}
dict2={}.fromkeys(('x','y'))
dict2={'x':None, 'y':None}

8 合并两个有序列表

知乎远程面试要求编程

尾递归
Python
def _recursion_merge_sort2(l1, l2, tmp):
    if len(l1) == 0 or len(l2) == 0:
        tmp.extend(l1)
        tmp.extend(l2)
        return tmp
    else:
        if l1[0] < l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
        return _recursion_merge_sort2(l1, l2, tmp)

def recursion_merge_sort2(l1, l2):
    return _recursion_merge_sort2(l1, l2, [])
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
	
def _recursion_merge_sort2(l1, l2, tmp):
    if len(l1) == 0 or len(l2) == 0:
        tmp.extend(l1)
        tmp.extend(l2)
        return tmp
    else:
        if l1[0] < l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
        return _recursion_merge_sort2(l1, l2, tmp)
 
def recursion_merge_sort2(l1, l2):
    return _recursion_merge_sort2(l1, l2, [])

循环算法
Python
def loop_merge_sort(l1, l2):
    tmp = []
    while len(l1) > 0 and len(l2) > 0:
        if l1[0] < l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
    tmp.extend(l1)
    tmp.extend(l2)
    return tmp
1
2
3
4
5
6
7
8
9
10
11
12
	
def loop_merge_sort(l1, l2):
    tmp = []
    while len(l1) > 0 and len(l2) > 0:
        if l1[0] < l2[0]:
            tmp.append(l1[0])
            del l1[0]
        else:
            tmp.append(l2[0])
            del l2[0]
    tmp.extend(l1)
    tmp.extend(l2)
    return tmp

9 交叉链表求交点

去哪儿的面试,没做出来.
Python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
def node(l1, l2):
    length1, lenth2 = 0, 0
    # 求两个链表长度
    while l1.next:
        l1 = l1.next
        length1 += 1
    while l2.next:
        l2 = l2.next
        length2 += 1
    # 长的链表先走
    if length1 > lenth2:
        for _ in range(length1 - length2):
            l1 = l1.next
    else:
        for _ in range(length2 - length1):
            l2 = l2.next
    while l1 and l2:
        if l1.next == l2.next:
            return l1.next
        else:
            l1 = l1.next
            l2 = l2.next
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
	
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
def node(l1, l2):
    length1, lenth2 = 0, 0
    # 求两个链表长度
    while l1.next:
        l1 = l1.next
        length1 += 1
    while l2.next:
        l2 = l2.next
        length2 += 1
    # 长的链表先走
    if length1 > lenth2:
        for _ in range(length1 - length2):
            l1 = l1.next
    else:
        for _ in range(length2 - length1):
            l2 = l2.next
    while l1 and l2:
        if l1.next == l2.next:
            return l1.next
        else:
            l1 = l1.next
            l2 = l2.next

10 二分查找

Python
def binarySearch(l, t):
    low, high = 0, len(l) - 1
    while low < high:
        print low, high
        mid = (low + high) / 2
        if l[mid] > t:
            high = mid
        elif l[mid] < t:
            low = mid + 1
        else:
            return mid
    return low if l[low] == t else False

if __name__ == '__main__':
    l = [1, 4, 12, 45, 66, 99, 120, 444]
    print binarySearch(l, 12)
    print binarySearch(l, 1)
    print binarySearch(l, 13)
    print binarySearch(l, 444)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
	
def binarySearch(l, t):
    low, high = 0, len(l) - 1
    while low < high:
        print low, high
        mid = (low + high) / 2
        if l[mid] > t:
            high = mid
        elif l[mid] < t:
            low = mid + 1
        else:
            return mid
    return low if l[low] == t else False
 
if __name__ == '__main__':
    l = [1, 4, 12, 45, 66, 99, 120, 444]
    print binarySearch(l, 12)
    print binarySearch(l, 1)
    print binarySearch(l, 13)
    print binarySearch(l, 444)

11 快排

Python
def qsort(seq):
    if seq==[]:
        return []
    else:
        pivot=seq[0]
        lesser=qsort([x for x in seq[1:] if x<pivot])
        greater=qsort([x for x in seq[1:] if x>=pivot])
        return lesser+[pivot]+greater

if __name__=='__main__':
    seq=[5,6,78,9,0,-1,2,3,-65,12]
    print(qsort(seq))
1
2
3
4
5
6
7
8
9
10
11
12
	
def qsort(seq):
    if seq==[]:
        return []
    else:
        pivot=seq[0]
        lesser=qsort([x for x in seq[1:] if x<pivot])
        greater=qsort([x for x in seq[1:] if x>=pivot])
        return lesser+[pivot]+greater
 
if __name__=='__main__':
    seq=[5,6,78,9,0,-1,2,3,-65,12]
    print(qsort(seq))

12 找零问题

Python
def  coinChange(values, money, coinsUsed):
    #values    T[1:n]数组
    #valuesCounts   钱币对应的种类数
    #money  找出来的总钱数
    #coinsUsed   对应于目前钱币总数i所使用的硬币数目
    for cents in range(1, money+1):
        minCoins = cents     #从第一个开始到money的所有情况初始
        for value in values:
            if value <= cents:
                temp = coinsUsed[cents - value] + 1
                if temp < minCoins:
                    minCoins = temp
        coinsUsed[cents] = minCoins
        print('面值为：{0} 的最小硬币数目为：{1} '.format(cents, coinsUsed[cents]) )

if __name__ == '__main__':
    values = [ 25, 21, 10, 5, 1]
    money = 63
    coinsUsed = {i:0 for i in range(money+1)}
    coinChange(values, money, coinsUsed)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
	
def  coinChange(values, money, coinsUsed):
    #values    T[1:n]数组
    #valuesCounts   钱币对应的种类数
    #money  找出来的总钱数
    #coinsUsed   对应于目前钱币总数i所使用的硬币数目
    for cents in range(1, money+1):
        minCoins = cents     #从第一个开始到money的所有情况初始
        for value in values:
            if value <= cents:
                temp = coinsUsed[cents - value] + 1
                if temp < minCoins:
                    minCoins = temp
        coinsUsed[cents] = minCoins
        print('面值为：{0} 的最小硬币数目为：{1} '.format(cents, coinsUsed[cents]) )
 
if __name__ == '__main__':
    values = [ 25, 21, 10, 5, 1]
    money = 63
    coinsUsed = {i:0 for i in range(money+1)}
    coinChange(values, money, coinsUsed)

13 广度遍历和深度遍历二叉树

给定一个数组，构建二叉树，并且按层次打印这个二叉树
Python
## 14 二叉树节点
class Node(object):
    def __init__(self, data, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right

tree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))

## 15 层次遍历
def lookup(root):
    stack = [root]
    while stack:
        current = stack.pop(0)
        print current.data
        if current.left:
            stack.append(current.left)
        if current.right:
            stack.append(current.right)
## 16 深度遍历
def deep(root):
    if not root:
        return
    print root.data
    deep(root.left)
    deep(root.right)

if __name__ == '__main__':
    lookup(tree)
    deep(tree)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
	
## 14 二叉树节点
class Node(object):
    def __init__(self, data, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right
 
tree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))
 
## 15 层次遍历
def lookup(root):
    stack = [root]
    while stack:
        current = stack.pop(0)
        print current.data
        if current.left:
            stack.append(current.left)
        if current.right:
            stack.append(current.right)
## 16 深度遍历
def deep(root):
    if not root:
        return
    print root.data
    deep(root.left)
    deep(root.right)
 
if __name__ == '__main__':
    lookup(tree)
    deep(tree)

17 前中后序遍历

深度遍历改变顺序就OK了
18 求最大树深

Python
def maxDepth(root):
        if not root:
            return 0
        return max(maxDepth(root.left), maxDepth(root.right)) + 1
1
2
3
4
	
def maxDepth(root):
        if not root:
            return 0
        return max(maxDepth(root.left), maxDepth(root.right)) + 1

19 求两棵树是否相同

Python
def isSameTree(p, q):
    if p == None and q == None:
        return True
    elif p and q :
        return p.val == q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)
    else :
        return False
1
2
3
4
5
6
7
	
def isSameTree(p, q):
    if p == None and q == None:
        return True
    elif p and q :
        return p.val == q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)
    else :
        return False

20 前序中序求后序

推荐: http://blog.csdn.net/hinyunsin/article/details/6315502
Python
def rebuild(pre, center):
    if not pre:
        return
    cur = Node(pre[0])
    index = center.index(pre[0])
    cur.left = rebuild(pre[1:index + 1], center[:index])
    cur.right = rebuild(pre[index + 1:], center[index + 1:])
    return cur

def deep(root):
    if not root:
        return
    deep(root.left)
    deep(root.right)
    print root.data
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
	
def rebuild(pre, center):
    if not pre:
        return
    cur = Node(pre[0])
    index = center.index(pre[0])
    cur.left = rebuild(pre[1:index + 1], center[:index])
    cur.right = rebuild(pre[index + 1:], center[index + 1:])
    return cur
 
def deep(root):
    if not root:
        return
    deep(root.left)
    deep(root.right)
    print root.data

21 单链表逆置

Python
class Node(object):
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next

link = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))

def rev(link):
    pre = link
    cur = link.next
    pre.next = None
    while cur:
        tmp = cur.next
        cur.next = pre
        pre = cur
        cur = tmp
    return pre

root = rev(link)
while root:
    print root.data
    root = root.next
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
	
class Node(object):
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next
 
link = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))
 
def rev(link):
    pre = link
    cur = link.next
    pre.next = None
    while cur:
        tmp = cur.next
        cur.next = pre
        pre = cur
        cur = tmp
    return pre
 
root = rev(link)
while root:
    print root.data
    root = root.next
