 一、ORM模型
    1.Django连接MySQL数据库
        在Django项目的settings.py文件中，配置数据库连接信息：
        DATABASES = {
            "default": {
                "ENGINE": "django.db.backends.mysql",
                "NAME": "你的数据库名称",  # 需要自己手动创建数据库
                "USER": "数据库用户名",
                "PASSWORD": "数据库密码",
                "HOST": "数据库IP",
                "POST": 3306
            }
        }
    2.在Django项目（注意，项目里的，不是app）的__init__.py文件中写如下代码，告诉Django使用pymysql模块连接MySQL数据库:
        import pymysql
        pymysql.install_as_MySQLdb()

    3.Django中ORM的（简单）增删改查
        增
        增加表
        下面这个例子定义了一个 Person 模型，包含  first_name  和  last_name 。
        from django.db import models
        class Person(models.Model):
            first_name = models.CharField(max_length=30)
            last_name = models.CharField(max_length=30)
        然后执行下面命令：
        python manage.py makemigrations
        python manage.py migrate
        first_name 和  last_name 是模型的字段。每个字段被指定为一个类属性，每个属性映射到一个数据库列。
        上面的 Person 模型将会像这样创建一个数据库表：
        CREATE TABLE myapp_person (
            "id" serial NOT NULL PRIMARY KEY,
            "first_name" varchar(30) NOT NULL,
            "last_name" varchar(30) NOT NULL
        );
        增加数据
        models.Person.object.create(first_name='fu',last_name='yong')
        删
        models.Person.object.get(id=1).delete()
        改
        obj = models.Person.object.get(id=1)
        obj.last_name = 'xiaoyong'
        obj.save()
        查
        models.Person.object.all() #查找所有记录，返回一个queryset对象
        models.Person.object.get(字段=值)  #按照字段查找
    4.字段
        AutoField(Field)                    -int自增列，必须填入参数primary_key=True
        
        BigAutoField(AutoField)             -bigint自增列，必须填入primary_key=True
            注：当model中如果没有自增列，则自动会创建一个列名为id的列
            from django.db import models
            class UserInfo(models.Model):
                # 自动创建一个列名为id的且为自增的整数列
                username = models.CharField(max_length=32)
            class Group(models.Model):
                # 自定义自增列
                nid = models.AutoField(primary_key=True)
                name = models.CharField(max_length=32)

        SmallIntegerField(IntegerField):        - 小整数 -32768 ～ 32767

        PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)        - 正小整数 0 ～ 32767
        IntegerField(Field)                                                           - 整数列(有符号的) -2147483648 ～ 2147483647
        PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)             - 正整数 0 ～ 2147483647
        BigIntegerField(IntegerField):                                      - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807
        BooleanField(Field)                                                           - 布尔值类型
        NullBooleanField(Field):                                                      - 可以为空的布尔值
        CharField(Field)                                                              - 字符类型必须提供max_length参数， max_length表示字符长度
        TextField(Field)                                                              - 文本类型
        EmailField(CharField)：                                                       - 字符串类型，Django Admin以及ModelForm中提供验证机制
        IPAddressField(Field)                                                         - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制
        GenericIPAddressField(Field)                                                  - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6
            - 参数：
                protocol，用于指定Ipv4或Ipv6， 'both',"ipv4","ipv6"
                unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol="both"
        URLField(CharField)                                                            - 字符串类型，Django Admin以及ModelForm中提供验证 URL
        SlugField(CharField)                                                           - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）
        CommaSeparatedIntegerField(CharField)                                          - 字符串类型，格式必须为逗号分割的数字
        UUIDField(Field)                                                               - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证
        FilePathField(Field)
            - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能
            - 参数：
                    path,                      文件夹路径
                    match=None,                正则匹配
                    recursive=False,           递归下面的文件夹
                    allow_files=True,          允许文件
                    allow_folders=False,       允许文件夹
       FileField(Field)
            - 字符串，路径保存在数据库，文件上传到指定目录
            - 参数：
                upload_to = ""      上传文件的保存路径
                storage = None      存储组件，默认django.core.files.storage.FileSystemStorage
       ImageField(FileField)
            - 字符串，路径保存在数据库，文件上传到指定目录
            - 参数：
                upload_to = ""      上传文件的保存路径
                storage = None      存储组件，默认django.core.files.storage.FileSystemStorage
                width_field=None,   上传图片的高度保存的数据库字段名（字符串）
                height_field=None   上传图片的宽度保存的数据库字段名（字符串）
        DateTimeField(DateField)
            - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]
        DateField(DateTimeCheckMixin, Field)
            - 日期格式      YYYY-MM-DD
        TimeField(DateTimeCheckMixin, Field)
            - 时间格式      HH:MM[:ss[.uuuuuu]]
        DurationField(Field)
            - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型
        FloatField(Field)
            - 浮点型
        DecimalField(Field)
            - 10进制小数
            - 参数：
                max_digits，小数总长度
                decimal_places，小数位长度
        BinaryField(Field)
        
    5.自定义char类型字段
        class FixedCharField(models.Field):
        """自定义的char类型的字段类"""
        def __init__(self, max_length, *args, **kwargs):
            self.max_length = max_length
            super(FixedCharField, self).__init__(max_length=max_length, *args, **kwargs)

        def db_type(self, connection):
            """限定生成数据库表的字段类型为char，长度为max_length指定的值 """
            return 'char(%s)' % self.max_length

        class Class(models.Model):
            id = models.AutoField(primary_key=True)
            title = models.CharField(max_length=25)
            # 使用自定义的char类型的字段
            cname = FixedCharField(max_length=25)
    
    6.注意事项
        1.触发Model中的验证和错误提示有两种方式：
            a. Django Admin中的错误信息会优先根据Admiin内部的ModelForm错误信息提示，如果都成功，才来检查Model的字段并显示指定错误信息
            b. 使用ModelForm
            c. 调用Model对象的 clean_fields 方法，如：
                # models.py
                class UserInfo(models.Model):
                    nid = models.AutoField(primary_key=True)
                    username = models.CharField(max_length=32)
                    email = models.EmailField(error_messages={'invalid': '格式错了.'})

                # views.py
                def index(request):
                    obj = models.UserInfo(username='11234', email='uu')
                    try:
                        print(obj.clean_fields())
                    except Exception as e:
                        print(e)
                    return HttpResponse('ok')
               # Model的clean方法是一个钩子，可用于定制操作，如：上述的异常处理。

        2.Admin中修改错误提示
            # admin.py
            from django.contrib import admin
            from model_club import models
            from django import forms
            class UserInfoForm(forms.ModelForm):
                age = forms.IntegerField(initial=1, error_messages={'required': '请输入数值.', 'invalid': '年龄必须为数值.'})
                class Meta:
                    model = models.UserInfo
                    # fields = ('username',)
                    fields = "__all__"
                    exclude = ['title']
                    labels = { 'name':'Writer', }
                    help_texts = {'name':'some useful help text.',}
                    error_messages={ 'name':{'max_length':"this writer name is too long"} }
                    widgets={'name':Textarea(attrs={'cols':80,'rows':20})}
            class UserInfoAdmin(admin.ModelAdmin):
                form = UserInfoForm
            admin.site.register(models.UserInfo, UserInfoAdmin)
    7.字段参数
        null                数据库中字段是否可以为空
        db_column           数据库中字段的列名
        default             数据库中字段的默认值
        primary_key         数据库中字段是否为主键
        db_index            数据库中字段是否可以建立索引
        unique              数据库中字段是否可以建立唯一索引
        unique_for_date     数据库中字段【日期】部分是否可以建立唯一索引
        unique_for_month    数据库中字段【月】部分是否可以建立唯一索引
        unique_for_year     数据库中字段【年】部分是否可以建立唯一索引

        verbose_name        Admin中显示的字段名称
        blank               Admin中是否允许用户输入为空
        editable            Admin中是否可以编辑
        help_text           Admin中该字段的提示信息
        choices             Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作
                            如：gf = models.IntegerField(choices=[(0, '何穗'),(1, '大表姐'),],default=1)

        error_messages      自定义错误信息（字典类型），从而定制想要显示的错误信息；
                            字典健：null, blank, invalid, invalid_choice, unique, and unique_for_date
                            如：{'null': "不能为空.", 'invalid': '格式错误'}

        validators          自定义错误验证（列表类型），从而定制想要的验证规则
                            from django.core.validators import RegexValidator
                            from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\
                            MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator
                            如：
                                test = models.CharField(
                                    max_length=32,
                                    error_messages={
                                        'c1': '优先错信息1',
                                        'c2': '优先错信息2',
                                        'c3': '优先错信息3',
                                    },
                                    validators=[
                                        RegexValidator(regex='root_\d+', message='错误了', code='c1'),
                                        RegexValidator(regex='root_112233\d+', message='又错误了', code='c2'),
                                        EmailValidator(message='又错误了', code='c3'), ]
                                )
    8.元信息
        class UserInfo(models.Model):
            nid = models.AutoField(primary_key=True)
            username = models.CharField(max_length=32)
            class Meta:
                # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名
                db_table = "table_name"
                # 联合索引
                index_together = [("pub_date", "deadline"),]
                # 联合唯一索引
                unique_together = (("driver", "restaurant"),)
                # admin中显示的表名称
                verbose_name
                # verbose_name加s
                verbose_name_plural
    9.多表关系和参数
        ForeignKey(ForeignObject) # ForeignObject(RelatedField)
            to,                         # 要进行关联的表名
            to_field=None,              # 要关联的表中的字段名称
            on_delete=None,             # 当删除关联表中的数据时，当前表与其关联的行的行为
                                            - models.CASCADE，删除关联数据，与之关联也删除
                                            - models.DO_NOTHING，删除关联数据，引发错误IntegrityError
                                            - models.PROTECT，删除关联数据，引发错误ProtectedError
                                            - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）
                                            - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）
                                            - models.SET，删除关联数据，
                                                          a. 与之关联的值设置为指定值，设置：models.SET(值)
                                                          b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)
                                             def func():
                                                 return 10
                                             class MyModel(models.Model):
                                                   user = models.ForeignKey(to="User", to_field="id",on_delete=models.SET(func),)
            related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()
            related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     
                                          如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名')
            limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：
                                        # 如：
                                                - limit_choices_to={'nid__gt': 5}
                                                - limit_choices_to=lambda : {'nid__gt': 5}

                                                from django.db.models import Q
                                                - limit_choices_to=Q(nid__gt=10)
                                                - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
                                                - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption='root')
            db_constraint=True          # 是否在数据库中创建外键约束
            parent_link=False           # 在Admin中是否显示关联数据


        OneToOneField(ForeignKey)
            to,                         # 要进行关联的表名
            to_field=None               # 要关联的表中的字段名称
            on_delete=None,             # 当删除关联表中的数据时，当前表与其关联的行的行为

                                        ###### 对于一对一 ######
                                        # 1. 一对一其实就是 一对多 + 唯一索引
                                        # 2.当两个类之间有继承关系时，默认会创建一个一对一字段
                                        # 如下会在A表中额外增加一个c_ptr_id列且唯一：
                                                class C(models.Model):
                                                    nid = models.AutoField(primary_key=True)
                                                    part = models.CharField(max_length=12)

                                                class A(C):
                                                    id = models.AutoField(primary_key=True)
                                                    code = models.CharField(max_length=1)

        ManyToManyField(RelatedField)
            to,                         # 要进行关联的表名
            related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()
            related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     
                                          如： models.UserGroup.objects.filter(表名__字段名=1).values('表名__字段名')
            limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：
                                        # 如：
                                                - limit_choices_to={'nid__gt': 5}
                                                - limit_choices_to=lambda : {'nid__gt': 5}

                                                from django.db.models import Q
                                                - limit_choices_to=Q(nid__gt=10)
                                                - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
                                                - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) & Q(caption='root')
            symmetrical=None,           # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段
                                        # 做如下操作时，不同的symmetrical会有不同的可选字段
                                            models.BB.objects.filter(...)

                                            # 可选字段有：code, id, m1
                                                class BB(models.Model):

                                                code = models.CharField(max_length=12)
                                                m1 = models.ManyToManyField('self',symmetrical=True)

                                            # 可选字段有: bb, code, id, m1
                                                class BB(models.Model):

                                                code = models.CharField(max_length=12)
                                                m1 = models.ManyToManyField('self',symmetrical=False)

            through=None,               # 自定义第三张表时，使用字段用于指定关系表
            through_fields=None,        # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表
                                            from django.db import models

                                            class Person(models.Model):
                                                name = models.CharField(max_length=50)

                                            class Group(models.Model):
                                                name = models.CharField(max_length=128)
                                                members = models.ManyToManyField(
                                                    Person,
                                                    through='Membership',
                                                    through_fields=('group', 'person'),
                                                )

                                            class Membership(models.Model):
                                                group = models.ForeignKey(Group, on_delete=models.CASCADE)
                                                person = models.ForeignKey(Person, on_delete=models.CASCADE)
                                                inviter = models.ForeignKey(
                                                    Person,
                                                    on_delete=models.CASCADE,
                                                    related_name="membership_invites",
                                                )
                                                invite_reason = models.CharField(max_length=64)
            db_constraint=True,         # 是否在数据库中创建外键约束
            db_table=None,              # 默认创建第三张表时，数据库中表的名称
    10.ORM操作
        # 增
        models.Tb1.objects.create(c1='xx', c2='oo')   # 增加一条数据，可以接受字典类型数据 **kwargs
        obj = models.Tb1(c1='xx', c2='oo')
        obj.save()
        # 查
        models.Tb1.objects.get(id=123)  # 获取单条数据，不存在则报错（不建议）
        models.Tb1.objects.all()  # 获取全部
        models.Tb1.objects.filter(name='seven')  # 获取指定条件的数据
        models.Tb1.objects.exclude(name='seven')  # 去除指定条件的数据
        # 删
        # models.Tb1.objects.filter(name='seven').delete()  # 删除指定条件的数据
        # 改
        models.Tb1.objects.filter(name='seven').update(gender='0')   # 将指定条件的数据更新，均支持 **kwargs
        obj = models.Tb1.objects.get(id=1)
        obj.c1 = '111'
        obj.save()   # 修改单条数据
   11.进阶操作
        # 获取个数
            # models.Tb1.objects.filter(name='seven').count()
            # 大于，小于
            # models.Tb1.objects.filter(id__gt=1)              # 获取id大于1的值
            # models.Tb1.objects.filter(id__gte=1)              # 获取id大于等于1的值
            # models.Tb1.objects.filter(id__lt=10)             # 获取id小于10的值
            # models.Tb1.objects.filter(id__lte=10)             # 获取id小于10的值
            # models.Tb1.objects.filter(id__lt=10, id__gt=1)   # 获取id大于1 且 小于10的值

            # in
            #
            # models.Tb1.objects.filter(id__in=[11, 22, 33])   # 获取id等于11、22、33的数据
            # models.Tb1.objects.exclude(id__in=[11, 22, 33])  # not in

            # isnull
            # Entry.objects.filter(pub_date__isnull=True)

            # contains
            #
            # models.Tb1.objects.filter(name__contains="ven")
            # models.Tb1.objects.filter(name__icontains="ven") # icontains大小写不敏感
            # models.Tb1.objects.exclude(name__icontains="ven")

            # range
            #
            # models.Tb1.objects.filter(id__range=[1, 2])   # 范围bettwen and

            # 其他类似
            #
            # startswith，istartswith, endswith, iendswith,

            # order by
            #
            # models.Tb1.objects.filter(name='seven').order_by('id')    # asc
            # models.Tb1.objects.filter(name='seven').order_by('-id')   # desc

            # group by
            #
            # from django.db.models import Count, Min, Max, Sum
            # models.Tb1.objects.filter(c1=1).values('id').annotate(c=Count('num'))
            # SELECT "app01_tb1"."id", COUNT("app01_tb1"."num") AS "c" FROM "app01_tb1" WHERE "app01_tb1"."c1" = 1 GROUP BY "app01_tb1"."id"

            # limit 、offset
            #
            # models.Tb1.objects.all()[10:20]

            # regex正则匹配，iregex 不区分大小写
            #
            # Entry.objects.get(title__regex=r'^(An?|The) +')
            # Entry.objects.get(title__iregex=r'^(an?|the) +')

            # date
            #
            # Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))
            # Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1))

            # year
            #
            # Entry.objects.filter(pub_date__year=2005)
            # Entry.objects.filter(pub_date__year__gte=2005)

            # month
            #
            # Entry.objects.filter(pub_date__month=12)
            # Entry.objects.filter(pub_date__month__gte=6)

            # day
            #
            # Entry.objects.filter(pub_date__day=3)
            # Entry.objects.filter(pub_date__day__gte=3)

            # week_day
            #
            # Entry.objects.filter(pub_date__week_day=2)
            # Entry.objects.filter(pub_date__week_day__gte=2)

            # hour
            #
            # Event.objects.filter(timestamp__hour=23)
            # Event.objects.filter(time__hour=5)
            # Event.objects.filter(timestamp__hour__gte=12)

            # minute
            #
            # Event.objects.filter(timestamp__minute=29)
            # Event.objects.filter(time__minute=46)
            # Event.objects.filter(timestamp__minute__gte=29)

            # second
            #
            # Event.objects.filter(timestamp__second=31)
            # Event.objects.filter(time__second=2)
            # Event.objects.filter(timestamp__second__gte=31)
   12.高级操作
    # extra
        # 在QuerySet的基础上继续执行子语句
        # extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)

        # select和select_params是一组，where和params是一组，tables用来设置from哪个表
        # Entry.objects.extra(select={'new_id': "select col from sometable where othercol > %s"}, select_params=(1,))
        # Entry.objects.extra(where=['headline=%s'], params=['Lennon'])
        # Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
        # Entry.objects.extra(select={'new_id': "select id from tb where id > %s"}, select_params=(1,), order_by=['-nid'])

    举个例子：
    models.UserInfo.objects.extra(
                        select={'newid':'select count(1) from app01_usertype where id>%s'},
                        select_params=[1,],
                        where = ['age>%s'],
                        params=[18,],
                        order_by=['-age'],
                        tables=['app01_usertype']
                    )
                    """
                    select 
                        app01_userinfo.id,
                        (select count(1) from app01_usertype where id>1) as newid
                    from app01_userinfo,app01_usertype
                    where 
                        app01_userinfo.age > 18
                    order by 
                        app01_userinfo.age desc
                    """
        # 执行原生SQL
        # 更高灵活度的方式执行原生SQL语句
        # from django.db import connection, connections
        # cursor = connection.cursor()  # cursor = connections['default'].cursor()
        # cursor.execute("""SELECT * from auth_user where id = %s""", [1])
        # row = cursor.fetchone()
   13.QuerySet相关方法
        def all(self)
            # 获取所有的数据对象
        def filter(self, *args, **kwargs)
            # 条件查询
            # 条件可以是：参数，字典，Q
        def exclude(self, *args, **kwargs)
            # 条件查询
            # 条件可以是：参数，字典，Q
        def select_related(self, *fields)
            性能相关：表之间进行join连表操作，一次性获取关联的数据。
            总结：
            1. select_related主要针一对一和多对一关系进行优化。
            2. select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。
        def prefetch_related(self, *lookups)
            性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。

            总结：
            1. 对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。
            2. prefetch_related()的优化方式是分别查询每个表，然后用Python处理他们之间的关系。
        def annotate(self, *args, **kwargs)
            # 用于实现聚合group by查询
            from django.db.models import Count, Avg, Max, Min, Sum
            v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id'))
            # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id

            v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')).filter(uid__gt=1)
            # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1

            v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id',distinct=True)).filter(uid__gt=1)
            # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1

        def distinct(self, *field_names)
            # 用于distinct去重
            models.UserInfo.objects.values('nid').distinct()
            # select distinct nid from userinfo

            注：只有在PostgreSQL中才能使用distinct进行去重

        def order_by(self, *field_names)
            # 用于排序
            models.UserInfo.objects.all().order_by('-id','age')

        def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)
            # 构造额外的查询条件或者映射，如：子查询

            Entry.objects.extra(select={'new_id': "select col from sometable where othercol > %s"}, select_params=(1,))
            Entry.objects.extra(where=['headline=%s'], params=['Lennon'])
            Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
            Entry.objects.extra(select={'new_id': "select id from tb where id > %s"}, select_params=(1,), order_by=['-nid'])

         def reverse(self):
            # 倒序
            models.UserInfo.objects.all().order_by('-nid').reverse()
            # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序


         def defer(self, *fields):
            models.UserInfo.objects.defer('username','id')
            或
            models.UserInfo.objects.filter(...).defer('username','id')
            #映射中排除某列数据

         def only(self, *fields):
            #仅取某个表中的数据
             models.UserInfo.objects.only('username','id')
             或
             models.UserInfo.objects.filter(...).only('username','id')

         def using(self, alias):
             指定使用的数据库，参数为别名（setting中的设置）


        ##################################################
        # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #
        ##################################################

        def raw(self, raw_query, params=None, translations=None, using=None):
            # 执行原生SQL
            models.UserInfo.objects.raw('select * from userinfo')

            # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名
            models.UserInfo.objects.raw('select id as nid from 其他表')

            # 为原生SQL设置参数
            models.UserInfo.objects.raw('select id as nid from userinfo where nid>%s', params=[12,])

            # 将获取的到列名转换为指定列名
            name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'}
            Person.objects.raw('SELECT * FROM some_other_table', translations=name_map)

            # 指定数据库
            models.UserInfo.objects.raw('select * from userinfo', using="default")

            ################### 原生SQL ###################
            from django.db import connection, connections
            cursor = connection.cursor()  # cursor = connections['default'].cursor()
            cursor.execute("""SELECT * from auth_user where id = %s""", [1])
            row = cursor.fetchone() # fetchall()/fetchmany(..)


        def values(self, *fields):
            # 获取每行数据为字典格式

        def values_list(self, *fields, **kwargs):
            # 获取每行数据为元祖

        def dates(self, field_name, kind, order='ASC'):
            # 根据时间进行某一部分进行去重查找并截取指定内容
            # kind只能是："year"（年）, "month"（年-月）, "day"（年-月-日）
            # order只能是："ASC"  "DESC"
            # 并获取转换后的时间
                - year : 年-01-01
                - month: 年-月-01
                - day  : 年-月-日

            models.DatePlus.objects.dates('ctime','day','DESC')

        def datetimes(self, field_name, kind, order='ASC', tzinfo=None):
            # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间
            # kind只能是 "year", "month", "day", "hour", "minute", "second"
            # order只能是："ASC"  "DESC"
            # tzinfo时区对象
            models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.UTC)
            models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.timezone('Asia/Shanghai'))

            """
            pip3 install pytz
            import pytz
            pytz.all_timezones
            pytz.timezone(‘Asia/Shanghai’)
            """

        def none(self):
            # 空QuerySet对象


        ####################################
        # METHODS THAT DO DATABASE QUERIES #
        ####################################

        def aggregate(self, *args, **kwargs):
           # 聚合函数，获取字典类型聚合结果
           from django.db.models import Count, Avg, Max, Min, Sum
           result = models.UserInfo.objects.aggregate(k=Count('u_id', distinct=True), n=Count('nid'))
           ===> {'k': 3, 'n': 4}

        def count(self):
           # 获取个数

        def get(self, *args, **kwargs):
           # 获取单个对象

        def create(self, **kwargs):
           # 创建对象

        def bulk_create(self, objs, batch_size=None):
            # 批量插入
            # batch_size表示一次插入的个数
            objs = [
                models.DDD(name='r11'),
                models.DDD(name='r22')
            ]
            models.DDD.objects.bulk_create(objs, 10)

        def get_or_create(self, defaults=None, **kwargs):
            # 如果存在，则获取，否则，创建
            # defaults 指定创建时，其他字段的值
            obj, created = models.UserInfo.objects.get_or_create(username='root1', 
                    defaults={'email': '1111111','u_id': 2, 't_id': 2})

        def update_or_create(self, defaults=None, **kwargs):
            # 如果存在，则更新，否则，创建
            # defaults 指定创建时或更新时的其他字段
            obj, created = models.UserInfo.objects.update_or_create(username='root1', 
                            defaults={'email': '1111111','u_id': 2, 't_id': 1})

        def first(self):
           # 获取第一个

        def last(self):
           # 获取最后一个

        def in_bulk(self, id_list=None):
           # 根据主键ID进行查找
           id_list = [11,21,31]
           models.DDD.objects.in_bulk(id_list)

        def delete(self):
           # 删除

        def update(self, **kwargs):
            # 更新

        def exists(self):
           # 是否有结果

   14.Django的分页器（paginator）
        语法：
            paginator = Paginator(book_list, 8) #8条一页
            print("count:", paginator.count) # 数据总数
            print("num_pages", paginator.num_pages) # 总页数
            print("page_range", paginator.page_range) # 页码的列表
            page1 = paginator.page(1) # 第1页的page对象
            for i in page1: # 遍历第1页的所有数据对象
                print(i)
            print(page1.object_list) # 第1页的所有数据

            page2 = paginator.page(2)
            print(page2.has_next()) # 是否有下一页
            print(page2.next_page_number()) # 下一页的页码
            print(page2.has_previous()) # 是否有上一页
            print(page2.previous_page_number()) # 上一页的页码

        views.py

            from django.shortcuts import render,HttpResponse
            # Create your views here.
            from django.shortcuts import render,HttpResponse
            # Create your views here.
            from app01.models import *
            from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
            from .models import *
            #添加数据
            def add(request):
                book_list=[]
                for i in range(1000):
                    book_obj=Book(title="book-%s"%i,price=i*24)
                    book_list.append(book_obj)
                Book.objects.bulk_create(book_list)
                return HttpResponse("添加成功")

            def index(request):
                '''
                    paginator = Paginator(book_list, 8) #8条一页
                    print("count:", paginator.count)  # 数据总数
                    print("num_pages", paginator.num_pages)  # 总页数
                    print("page_range", paginator.page_range)  # 页码的列表
                    page1 = paginator.page(1)  # 第1页的page对象
                    for i in page1:  # 遍历第1页的所有数据对象
                        print(i)
                    print(page1.object_list)  # 第1页的所有数据
                    page2 = paginator.page(2)
                    print(page2.has_next())  # 是否有下一页
                    print(page2.next_page_number())  # 下一页的页码
                    print(page2.has_previous())  # 是否有上一页
                    print(page2.previous_page_number())  # 上一页的页码

                :param request:
                :return:
                '''
                current_page=int(request.GET.get("page",1))
                book_list=Book.objects.all()

                paginator=Paginator(book_list,10)
                page=paginator.page(current_page)

            #如果页数超过一定数量，就换方式展示
                if paginator.num_pages > 11:
                    if current_page - 5 < 1:
                        pageRange = range(1, 11)
                    elif current_page + 5 > paginator.num_pages:
                        pageRange = range(paginator.num_pages - 9, paginator.num_pages + 1)
                    else:
                        pageRange = range(current_page - 5, current_page + 5)
                else:
                    pageRange = paginator.page_range

                return render(request,"index.html",locals())

        index.html
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
                <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
            <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
            </head>
            <body>
            <ul>
                {% for book in page %}
                <li>{{ book.title }}-----{{ book.price }}</li>
                {% endfor %}
            </ul>
            <nav aria-label="Page navigation">
              <ul class="pagination">
                <li>
                  <a href="?page={{ current_page|add:-1 }}" aria-label="Previous">
                    上一页
                  </a>
                </li>
                  {% for num in pageRange %}
                      {% if current_page == num %}
                          <li class="active"><a href="?page={{ num }}">{{ num }}</a></li>
                      {% else %}
                          <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                  {% endfor %}
                {% if page.has_next %}
                    <li><a href="?page={{ current_page|add:1 }}" aria-label="Next">下一页</a></li>
                {% else %}
                {% endif %}
              </ul>
            </nav>
          </body>
          </html>

    urls.py
        """page_demo URL Configuration

        The `urlpatterns` list routes URLs to views. For more information please see:
            https://docs.djangoproject.com/en/1.11/topics/http/urls/
        Examples:
        Function views
            1. Add an import:  from my_app import views
            2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
        Class-based views
            1. Add an import:  from other_app.views import Home
            2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
        Including another URLconf
            1. Import the include() function: from django.conf.urls import url, include
            2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
        """
        from django.conf.urls import url
        from django.contrib import admin
        from app01 import views
        urlpatterns = [
            url(r'^admin/', admin.site.urls),
            url(r'^add/', views.add),
            url(r'^index/', views.index),
        ]

       
       models.py
        from django.db import models
        # Create your models here.
        class Book(models.Model):
            title=models.CharField(max_length=32)
            price=models.DecimalField(max_digits=8,decimal_places=2)

        
   15.django模型注册及用户创建
        创建应用程序
            django项目由一系列应用程序组成，他们协同工作，让项目称谓一个整体。首先我们执行命令 python manage.py startapp learning_logs 
        定义模型
            打开刚刚我们创建的文件夹，并修改models.py：
            from django.db import models
            class Topic(models.Model):
                text = models.CharField(max_length=200)
                date_added = models.DateTimeField(auto_now_add=True)
                def __str__(self):
                    return self.text

            我们为模型创建了一个名为Topic的类，他继承了Model——django中一个定义模型基本功能的类。Topic类只有两个属性： text 和 date_added 。
            text 是一个 CharField ——由字符或文本组成的数据，可存储少量文本。传入参数 **max_length** 为文本最大长度。
            date_added 是一个 DateField ——记录日期和时间的数据。传入的实参 auto_add_now=True 告诉django每当用户新建主题时，
        将这个属性自动设置为当前日期和时间。
        
        激活模型
            打开learning_log中的setting.py并添加
            INSTALLED_APPS = [
                'django.contrib.admin',
                'django.contrib.auth',
                'django.contrib.contenttypes',
                'django.contrib.sessions',
                'django.contrib.messages',
                'django.contrib.staticfiles',
                'learning_logs', #<-here
            ]
            这是一个元组，包含了django项目中的所有应用程序。接着执行 python manage.py makemigrations learning_logs 
         让django确定如何修改数据库。最后应用迁移，执行 python manage.py migrate 。
         
          Django管理网站
            1.创建超级用户，执行命令 python manage.py createsuperuser 。
            2.向管理网站注册模型，打开 learning_logs下的admin.py，并修改为：
            from django.contrib import admin
            from learning_logs.models import Topic
            admin.site.register(Topic)
            这写代码导入了我们要注册的模型Topic，接着使用 admin.site.register(Topic) 让django通过管理网站管理我们的模型。
            接着运行服务器，访问 http://127.0.0.1:8000/admin 并使用着急用户帐号密码登录。
            3.添加主题，点击Topic之后进入主题网页，此时可以通过点击add进行主题的添加，添加完成之后点击save进行保存。
            
            定义模型Entry
            learning_logs\models.py
            from django.db import models
            class Topic(models.Model):
                text = models.CharField(max_length=200)
                date_added = models.DateTimeField(auto_now_add=True)
                def __str__(self):
                    return self.text
            class Entry(models.Model):
                topic = models.ForeignKey(Topic)
                text = models.TextField()
                date_added = models.DateTimeField(auto_now_add=True)
                class Meta:
                    verbose_name_plural = 'entries'
                def __str__(self):
                    return self.text[:50] + "..."
            ForeignKey 是数据库的外键，引用数据库中的另一个记录。Entry类中的 Meta类 用于存储管理模型的额外信息，这里设置了一个特殊属性，让django在需要时使用 Entries 来表示多个条目。

            迁移模型Entry
            由于我们添加了一个新模型，因此需要再次迁移数据库。执行命令 python manage.py makemigrations learning_logs 以及 python manage.py migrate .
            向管理网站注册Entry
            修改如下文件
            learning_logs\admin.py
            from django.contrib import admin
            from learning_logs.models import Topic, Entry
            admin.site.register(Topic)
            admin.site.register(Entry)
            返回管理网站可以发现多了一个板块
16.Django中间件的总结
     一、中间件
        --中间件是一个轻量级、底层的插件系统，可以加入Django的请求和响应过程，修改Django的输入和输出
        --每一个中间件组件是一个独立的Python类，可以定义下面方法中的一个和多个
        --__init__：无需要任何参数，服务器响应的第一个请求的时候调用一次，用于确定是否启用当前的中间件
        --process_request(request):执行视图之前被调用，在每个请求上调用，返回None或 HttpResponse对象
        --process_view(request,view_func,view_args,view_kwargs):调用视图函数之前被调用，在每个请求上被调用，返回None或HtppResponse对象
        --process_template_response(request,response):在视图刚好执行完毕之后被调用，再每一个请求上调用，返回实现了render方法的响应对象
        --process_response(request,response):所有响应返回浏览器之前被调用，在每一个请求上调用，返回HttpResponse对象
        --process_exception(request,response,exception):当视图抛出异常是调用，在每个请求上调用，返回一个HttpResponse对象
        a、中间件是什么？
            --中间件是一个类
        b、返回值注意是什么？
            --无返回值：继续执行后续函数中间件和视图函数
            --有返回值：有返回值执行process_response和上面的response
        c、中间件做过什么：
            --用户登录
            --日志记录
            --权限管理
            --session
            --csrf
        d、中间件和装饰器的区别
         
        MIDDLEWARE 这里列表中的每一个元素，其实就是一个个单独的中间件，举例来说： django.middleware.csrf.CsrfViewMiddleware 这个中间件，
     作用就是在我们的 form 表单提交请求的时候，提交的时候必须要带上 csrf_token ，否则就不会正确提交。

        中间件使用也需要讲究顺序，下一层依赖上一层的封装，例如，我们的 AuthenticationMiddleware 是一个认证中间件，在session中保存认证用户
     的信息，但是他必须依赖于 SessionMiddleware 才可以被正确使用，所以他也必须在 SessionMiddleware 之后。但是具体的顺序问题可以参考 这里
     中间件结构

    中间件类中需要包含以下处理方法：

    1. process_request(self, request)
    2. process_view(self, request, callback, callback_args, callback_kwargs)
    3. process_template_response(self, request, response)
    4. process_exception(self, request, exception)
    5. process_response(self, request, response)
   
   中间件执行前提
        中间件要按照一定的顺序一层一层的执行下去，需要按照标准返回特定的内容：
        如果为 None，则按照顺序继续向下执行
        如果为 HttpResonse 对象，则直接将这个对象返回给用户
        此处有一个版本前后的区别，请大家注意区分：
        在 Django1.10之后， 当某个中间件，例如 CsrfViewMiddleware 请求 process_request 没有返回 None 后，
        这个请求会交给 CsrfViewMiddleware 的 process_response 来返回，即返回给相同一层的中间件来返回:
        
17.Django Markdown富文本app插件
     功能
        支持 Editor.md 大部分功能
            支持标准的Markdown 文本、 CommonMark 和 GFM (GitHub Flavored Markdown) 文本;
            支持实时预览、图片上传、格式化代码、搜索替换、皮肤、多语言等。
            支持TOC 目录和表情；
            支持 TeX, 流程图、时序图等图表扩展。
        可自定义 Editor.md 工具栏。
        提供了 MDTextField 字段用来支持模型字段使用。
        提供了 MDTextFormField 字段用来支持 Form 和 ModelForm .
        提供了 MDEditorWidget 字段用来支持 admin 自定义样式使用。
    快速入门
        安装
    pip install django-mdeditor
        在 settings 配置文件 INSTALLED_APPS 中添加 mdeditor :
    INSTALLED_APPS = [
            ...
            'mdeditor',
        ]
        在 settings 中添加媒体文件的路径配置:
    MEDIA_ROOT = os.path.join(BASE_DIR, 'uploads')
    MEDIA_URL = '/media/'
    在你项目根目录下创建 uploads/editor 目录，用于存放上传的图片。
        在你项目的根 urls.py 中添加扩展url和媒体文件url:
    from django.conf.urls import url, include
    from django.conf.urls.static import static
    from django.conf import settings
    ...
    urlpatterns = [
        ...
        url(r'mdeditor/', include('mdeditor.urls'))
    ]
    if settings.DEBUG:
        # static files (images, css, javascript, etc.)
        urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
        编写一个测试 model :
    from django.db import models
    from mdeditor.fields import MDTextField
    class ExampleModel(models.Model):
        name = models.CharField(max_length=10)
        content = MDTextField()

        向 admin.py 中注册model:
    from django.contrib import admin
    from . import models
    admin.site.register(models.ExampleModel)

        运行 python manage.py makemigrations 和 python manage.py migrate 来创建你的model 数据库表.
        登录 django admin后台，点击 '添加'操作，你会看到如下界面。
    到此，你已经初步体验了 djang-mdeditor ，接下来详细看下他的其他使用吧。
    用法说明
    在model 中使用 Markdown 编辑字段
    在model 中使用 Markdown 编辑字段，我们只需要将 model 的 TextField 替换成 MDTextField 即可。
    from django.db import models
    from mdeditor.fields import MDTextField

    class ExampleModel(models.Model):
        name = models.CharField(max_length=10)
        content = MDTextField()

    在后台admin中，会自动显示 markdown 的编辑富文本。
    在前端 template 中使用时，可以这样用：
    {% load staticfiles %}
    <!DOCTYPE html>
    <html lang="zh">
        <head>
            <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        </head>
        <body>
            <form method="post" action="./">
                {% csrf_token %}
                {{ form.media }}
                {{ form.as_p }}
                <p><input type="submit" value="post"></p>
            </form>
        </body>
    </html>

    在 Form 中使用 markdown 编辑字段
    在 Form 中使用 markdown 编辑字段，使用 MDTextFormField 代替 forms.CharField , 如下：
    from mdeditor.fields import MDTextFormField

    class MDEditorForm(forms.Form):
        name = forms.CharField()
        content = MDTextFormField()

    ModelForm 可自动将model 对应的字段转为 form字段， 可正常使用：
    class MDEditorModleForm(forms.ModelForm):
        class Meta:
            model = ExampleModel
            fields = '__all__'

    在 admin 中使用 markdown 小组件
    在 admin 中使用 markdown 小组件，如下：

    from django.contrib import admin
    from django.db import models
    # Register your models here.
    from . import models as demo_models
    from mdeditor.widgets import MDEditorWidget

    class ExampleModelAdmin(admin.ModelAdmin):
        formfield_overrides = {
            models.TextField: {'widget': MDEditorWidget}
        }

    admin.site.register(demo_models.ExampleModel, ExampleModelAdmin)
    
18.django-celery

19.Django的Model使用
     创建模型
    使用Django的模型主要注意两个方面：字段的类型和方法的重写。这里用一个例子来说明，其中包含了常用的字段类型和如何重写方法。
    from django.db import models
    class School(models.Model):
        pass
    class Message(models.Model):
        pass
    class Teacher(models.Model):
        pass
    class Student(models.Model):
        GENDER_CHOICES = (
            ('male', "男"),
            ('female', "女"),
            ('secret', "保密")
        )

        name = models.CharField(max_length=40, blank=True, verbose_name="姓名")
        gender = models.CharField(max_length=6, choices=GENDER_CHOICES, default="secret", verbose_name="性别")
        age = models.IntegerField(default=0, verbose_name="年龄")
        rank = models.PositiveIntegerField(default=1, verbose_name="排名", unique=True)
        discount = models.DecimalField(max_digits=3, decimal_places=2, verbose_name="折扣", default=1.0)
        school = models.ForeignKey(to=School, verbose_name="学校", on_delete=models.CASCADE)
        message = models.OneToOneField(to=Message, verbose_name="信息", on_delete=models.CASCADE)
        teacher = models.ManyToManyField(verbose_name="老师", to=Teacher, blank=True)
        introduce = models.TextField(blank=True, verbose_name="介绍")
        grade = models.FloatField(default=0.0, verbose_name="成绩")
        url = models.URLField(verbose_name="个人主页", max_length=100)
        email = models.EmailField(verbose_name="邮箱")
        image = models.ImageField(upload_to='img/%Y/%m/%d/', verbose_name='上传图片', null=True)
        file = models.FileField(upload_to="file/%Y/%m/%d/", verbose_name="上传文件", blank=True)
        is_deleted = models.BooleanField(verbose_name="已删除", default=False, blank=True)
        time_added = models.DateTimeField(verbose_name="添加时间", auto_now_add=True, blank=True)

        def delete(self, using=None, keep_parents=False):
            self.is_deleted = True
            # some actions
            self.save()

        def save(self, force_insert=False, force_update=False, using=None,
                 update_fields=None):
            # some actions
            self.name = self.name.capitalize()  # 首字母大写
            return super().save(force_insert=force_insert, force_update=force_update, using=using,
                                update_fields=update_fields)

        def __repr__(self):
            return "UserProfile:{}".format(self.name)

        def __str__(self):
            return self.name

        class Meta:
            ordering = ['-time_added']
            verbose_name = "用户信息"
            verbose_name_plural = verbose_name
            db_table = "student_info"

    字段类型

    这里对常见字段中值得注意的地方作一下说明。
    CharField

    字符串类型值得注意的是当该字段只能在是某些指定的值时，要使用choices参数来指向预先设定的值。
    IntergerField & PositiveIntegerField

    整数类型和正整数类型。
    DecimalField

    十进制浮点数，其中，参数max_digits代表数字有多少位，decimal_places代表小数部分有多少位。
    ForeignKey

    使用to指向被关联的模型，使用on_delete来规定被关联对象删除时该对象的处理方式。主要有两种取值，models.CASCADE和models.SET_NULL。models.CASCADE表示当被关联对象删除时删除该对象，models.SET_NULL表示当被关联对象被删除时将该对象设置为空，此设置的前提是该字段要允许为空。
    ImageField & FileField

    使用upload_to参数来指定文件保存的路径。注意，该路径前面再加上 MEDIA_ROOT中设置的路径就是上传的文件真实保存路径了，如 MEDIA_ROOT的路径是'/home/media'，那图片上传的路径就类似/home/media/img/2018/03/06。
    BooleanField

    布尔类型，可以使用default指定默认值。
    DateTimeField

    在Django中，代表时间字段的有三种：DateTimeField、DateField、TimeField，三种类型分别对应datetime()、date()、time()，都有auto_now和auto_now_add参数。

        auto_now
        默认值为False，设置为True时会在每次修改该对象时自动更新为当前时间，但是无法手动修改该字段的值。
        auto_now_add
        默认值为False，设置为True时会在创建对象时自动设置为当前时间，之后都不再修改，也不能手动修改其值。

        默认当前时间，又能修改

        有时候我们需要在创建对象时设置字段的值为当前时间，在后续时又能修改，使用auto_now或者auto_now_add都无法实现这一点。此时，可以使用default参数来设置默认值，如下

        from django.db import models
        from django.utils import timezone
        class Message(models.Model):
        add_date = models.DateTimeField(verbose_name='保存日期',default = timezone.now)
        mod_date = models.DateTimeField(verbose_name='最后修改日期', auto_now = True)

    重写方法
    delete

    Django默认的删除是将数据从数据库里删除，有时候我们需要软删除，保存以前的数据，这时候我们可以使用一个布尔类型的字段标识该条数据是否删除，这时需要重写delete方法实现软删除。

    在delete方法中将is_deleted的值设置为True，表示该条数据已删除。此外还可以执行一些关联的动作，比如对相关字段赋值等，最后保存对象。
    save

    重写save方法可以让我们在保存数据时做一些相关的操作，比如保存姓名时自动设置为首字母大写，执行完之后需要调用父类的save方法进行保存。
    repr & str

    两者的作用是将变量或者常量转换为字符串对象，这里重写该方法使得对象实例能被转化为字符串。
    class Meta

        ordering：结果集按照何种方式排序，上面例子表示按添加时间的逆序排序
        verbose_name：对象的名称
        verbose_name_plural：对象复数形式的名称
        db_table：在数据库中的表名

    常用方法

    在对常用方法介绍部分，由于上面的模型包含字段较多，所以不使用上面创建的模型。这里使用一些常见的模型，通过名字就可以知道代表的内容，因此就不列出模型了。
    创建实例
    create

    使用create方法可以创建一个模型实例，将各字段在参数中设置各个字段的值。

    student = Student.objects.create(name='zhangsan', gender='male')

    get_or_create

    get_or_create的作用是查询一个实例，当实例不存在时则创建一个实例。

    obj, created = Person.objects.get_or_create(
        first_name='John',
        last_name='Lennon',
        defaults={'birthday': date(1940, 10, 9)},
    )

    函数返回一个(object, created)的tuple，object是查询或者创建的对象实例，created是个布尔类型的值，表示是否是新创建的实例。在查询时使用defaults以外的参数进行查询，当实例不存在时将包含default参数一起创建一个新的实例。功能类似于如下代码：

    try:
        obj = Person.objects.get(first_name='John', last_name='Lennon')
    except Person.DoesNotExist:
        obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
        obj.save()

    update_or_create

    update_or_create的作用是更新一个实例，当实力不存在时则创建一个实例。

    obj, created = Person.objects.update_or_create(
        first_name='John', last_name='Lennon',
        defaults={'first_name': 'Bob'},
    )

    函数返回一个(object, created)的tuple，object是更新或者创建的对象实例，created是个布尔类型的值，表示是否是新创建的实例。在查询的对象实例存在时，使用default中的参数进行更新，当实例不存在时，创建新的对象实例，需要更新的字段的值设置为default中的值。功能类似：

    defaults = {'first_name': 'Bob'}
    try:
        obj = Person.objects.get(first_name='John', last_name='Lennon')
        for key, value in defaults.items():
            setattr(obj, key, value)
        obj.save()
    except Person.DoesNotExist:
        new_values = {'first_name': 'John', 'last_name': 'Lennon'}
        new_values.update(defaults)
        obj = Person(**new_values)
        obj.save()

    add

    这里补充一下add方法，add用在多对多的关系模型上，表示添加该字段的指向对象。

    >>> john = Author.objects.create(name="John")
    >>> paul = Author.objects.create(name="Paul")
    >>> george = Author.objects.create(name="George")
    >>> ringo = Author.objects.create(name="Ringo")
    >>> entry.authors.add(john, paul, george, ringo)

    上面的Author表示作者模型，entry表示书籍条目，一本书可以有多个作者，采用多对多关系。add可以为书的实例添加多个作者。
    查询
    all

    all方法查询该对象的所有实例。

    all_entries = Entry.objects.all()

    get

    使用get查询实例，当实例不存在时会返回一个不存在异常。

    >>> entry = Entry.objects.get(pk=1)
    >>> cheese_blog = Blog.objects.get(name="Cheddar Talk")

    filter

    filter返回一个QuerySet，而不是对象实例，当查询结果不存在时返回空的QuerySet，而不是返回一场，可以对结果集作切片操作来获取实例内容。下面代码功能在有对象实例时等同于上面get的操作。

    >>> entry = Entry.objects.filter(pk=1)[0]
    >>> cheese_blog = Blog.objects.filter(name="Cheddar Talk")[0]

    filter结果可以链式地进行操作，也就是后面可以接多个过滤条件。

    Entry.objects.filter(pub_date__year=2006)
    Entry.objects.all().filter(pub_date__year=2006)
    Entry.objects.filter(blog__name__year="zhangsan")

    上面的pub_date__year表示取出DateField类型的pub_date的年，类似的可以取出月__month,日__day。在使用外键ForeignKey时可以使用双下划线来表示被关联对象的字段。

    现在来看一下链式过滤的例子。

    Entry.objects.filter(
    ...     headline__startswith='What'
    ... ).exclude(
    ...     pub_date__gte=datetime.date.today()
    ... ).filter(
    ...     pub_date__gte=datetime.date(2005, 1, 30)
    ... )

    首先使用__startswith过滤标题以'What'开始的数据。然后保留让发布日期小于今天的数据，exclude表示排除条件内的那部分数据，条件使用了__gte表示大于当前日期,该部分过滤类似于filter后面使用__lte小于。最后也是使用__gte大于一个自定义的日期。

    除了上面的过滤条件外，常见的还有__icontains，表示包含该内容。
    Q

    Q是Django自带的内容，用于查询。主要的用途是在页面的搜索框中输入内容后台查询相应的数据集。

    student = student.filter(Q(name__icontains=search) |
                             Q(teacher__name__icontains=search) |
                             Q(gender__icontains=search) |
                             Q(url__icontains=search))

    上述例子常用在一个搜索框可能搜索多个字段的内容时，各个过滤条件之间使用“|”进行或者运算。当多条件查询时，各个条件是并运算，使用“&”代替“|”。

    Q可以复制给个变量，有时候我们需要对Q后面的内容先做一些处理，如将日期拼凑出来等，这时候可以先把Q赋值给一个变量，然后对变量进行“|”或者“&”操作。

    query = Q(name__icontains=search)
    query = query | Q(teacher__name__icontains=search)
    student = student.filter(query)

20.Django中的缓存
     一、Django缓存
    Django提供了不同粒度的缓存,可以缓存某个页面,可以只缓存一个页面的某个部分,甚至可以缓存整个网站.
    数据库：
    class Book(models.Model):
        name=models.CharField(max_length=32)
        price=models.DecimalField(max_digits=6,decimal_places=1)
    视图：
    from django.views.decorators.cache import cache_page
    import time
    from .models import *

    @cache_page(15)          #超时时间为15秒
    def index(request):

         t=time.time()      #获取当前时间
         bookList=Book.objects.all()
         return render(request,"index.html",locals())

    模板：

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <h3>当前时间:-----{{ t }}</h3>

    <ul>
        {% for book in bookList %}
           <li>{{ book.name }}--------->{{ book.price }}$</li>
        {% endfor %}
    </ul>

    </body>
    </html>

    上面的例子是基于内存的缓存配置,基于文件的缓存该怎么配置呢??

    更改settings.py的配置

    CACHES = {
     'default': {
      'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache', # 指定缓存使用的引擎
      'LOCATION': 'E:\django_cache',          # 指定缓存的路径
      'TIMEOUT': 300,              # 缓存超时时间(默认为300秒,None表示永不过期)
      'OPTIONS': {
       'MAX_ENTRIES': 300,            # 最大缓存记录的数量（默认300）
       'CULL_FREQUENCY': 3,           # 缓存到达最大个数之后，剔除缓存个数的比例，即：1/CULL_FREQUENCY（默认3）
      }
     }
    }

    然后再次刷新浏览器,可以看到在刚才配置的目录下生成的缓存文件

    通过实验可以知道,Django会以自己的形式把缓存文件保存在配置文件中指定的目录中.
    1.3.2 全站使用缓存

    既然是全站缓存,当然要使用Django中的中间件.

    用户的请求通过中间件,经过一系列的认证等操作,如果请求的内容在缓存中存在,则使用FetchFromCacheMiddleware获取内容并返回给用户

    当返回给用户之前,判断缓存中是否已经存在,如果不存在,则UpdateCacheMiddleware会将缓存保存至Django的缓存之中,以实现全站缓存

    缓存整个站点，是最简单的缓存方法

    在 MIDDLEWARE_CLASSES 中加入 “update” 和 “fetch” 中间件
    MIDDLEWARE_CLASSES = (
        ‘django.middleware.cache.UpdateCacheMiddleware’, #第一
        'django.middleware.common.CommonMiddleware',
        ‘django.middleware.cache.FetchFromCacheMiddleware’, #最后
    )
    “update” 必须配置在第一个
    “fetch” 必须配置在最后一个

    修改settings.py配置文件


    MIDDLEWARE_CLASSES = (
        'django.middleware.cache.UpdateCacheMiddleware',   #响应HttpResponse中设置几个headers
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.auth.middleware.SessionAuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
        'django.middleware.security.SecurityMiddleware',
        'django.middleware.cache.FetchFromCacheMiddleware',   #用来缓存通过GET和HEAD方法获取的状态码为200的响应

    )


    CACHE_MIDDLEWARE_SECONDS=10

    setting

    视图函数：

    from django.views.decorators.cache import cache_page
    import time
    from .models import *


    def index(request):

         t=time.time()      #获取当前时间
         bookList=Book.objects.all()
         return render(request,"index.html",locals())

    def foo(request):
        t=time.time()      #获取当前时间
        return HttpResponse("HELLO:"+str(t))

    模板（index.html）:

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <h3 style="color: green">当前时间:-----{{ t }}</h3>

    <ul>
        {% for book in bookList %}
           <li>{{ book.name }}--------->{{ book.price }}$</li>
        {% endfor %}
    </ul>

    </body>
    </html>

    其余代码不变,刷新浏览器是10秒,页面上的时间变化一次,这样就实现了全站缓存.
    1.3.3 局部视图缓存

    例子,刷新页面时,整个网页有一部分实现缓存

    views视图函数

    from django.views.decorators.cache import cache_page
    import time
    from .models import *


    def index(request):

         t=time.time()      #获取当前时间
         bookList=Book.objects.all()

         return render(request,"index.html",locals())

    模板（index.html）:

    {% load cache %}
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
     <h3 style="color: green">不缓存:-----{{ t }}</h3>

    {% cache 2 'name' %}
     <h3>缓存:-----:{{ t }}</h3>
    {% endcache %}

    </body>
    </html> 
21.自定义admin站点
     一、定制模型表单
        在前面的学习过程中，通过 admin.site.register(Question) 语句，我们在admin站点中注册了Question模型。Django会自动生成一个该模型的默认表单页面。如果你想自定义该页面的外观和工作方式，可以在注册对象的时候告诉Django你的自定义选项。
        下面是一个修改admin表单默认排序方式的例子。修改 polls/admin.py 的代码：：
        from django.contrib import admin
        from .models import Question
        class QuestionAdmin(admin.ModelAdmin):
            fields = ['pub_date', 'question_text']
        admin.site.register(Question, QuestionAdmin)
        你只需要创建一个继承 admin.ModelAdmin 的模型管理类，然后将它作为第二个参数传递给 admin.site.register() ，第一个参数则是Question模型本身。
        上面的修改让 Publication date 字段显示在 Question 字段前面了（默认是在后面）。
         对于只有2个字段的情况，效果看起来还不是很明显，但是如果你有一打的字段，选择一种直观的符合我们人类习惯的排序方式则非常有用。

        还有，当表单含有大量字段的时候，你也许想将表单划分为一些字段的集合。再次修改 polls/admin.py :
        from django.contrib import admin
        from .models import Question
        class QuestionAdmin(admin.ModelAdmin):
            fieldsets = [
                (None,               {'fields': ['question_text']}),
                ('Date information', {'fields': ['pub_date']}),
            ]
        admin.site.register(Question, QuestionAdmin)
        字段集合 fieldsets 中每一个元组的第一个元素是该字段集合的标题。
    二、添加关联对象
        虽然我们已经有了Question的管理页面，但是一个Question有多个Choices，如果想显示Choices的内容怎么办？
        有两个办法可以解决这个问题。第一个是像Question一样将Choice注册到admin站点，这很容易，修改 polls/admin.py ，增加下面的内容：
        from django.contrib import admin
        from .models import Choice, Question
        # ...
        admin.site.register(Choice)
        重启服务器，再次访问admin页面，就可以看到Choice条目了
         在这个表单中，Question字段是一个select选择框，包含了当前数据库中所有的Question实例。 Django在admin站点中，
     自动地将所有的外键关系展示为一个select框。 在我们的例子中，目前只有一个question对象存在。

        请注意图中的绿色加号，它连接到Question模型。每一个包含外键关系的对象都会有这个绿色加号。点击它，会弹出一个新增
     Question的表单，类似Question自己的添加表单。填入相关信息点击保存后，Django自动将该Question保存在数据库，并作为当前
     Choice的关联外键对象。白话讲就是，新建一个Question并作为当前Choice的外键。

        但是实话说，这种创建方式的效率不怎么样。如果在创建Question对象的时候就可以直接添加一些Choice，那会更好，这就是我们
     要说的第二种方法。下面，让我们来动手试试。

        首先，删除 polls/admin.py 中Choice模型对 register() 方法的调用。然后，编辑Question的内容，最后整个文件的代码应该如下：
        from django.contrib import admin
        from .models import Choice, Question
        class ChoiceInline(admin.StackedInline):
            model = Choice
            extra = 3
        class QuestionAdmin(admin.ModelAdmin):
            fieldsets = [
                (None,               {'fields': ['question_text']}),
                ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
            ]
            inlines = [ChoiceInline]
        admin.site.register(Question, QuestionAdmin)
        上面的代码相当于告诉Django，Choice对象将在Question管理页面进行编辑，默认情况，请提供3个Choice对象的编辑区域。
        重启服务器，进入“Add question”页面，应该看到如下图所示：
        
         在3个插槽的最后，还有一个 Add another Choice 链接。点击它，又可以获得一个新的插槽。如果你想删除新增的插槽，
         点击它最右边的灰色X图标即可。但是，默认的三个插槽不可删除。

        这里还有点小问题。上面页面中插槽纵队排列的方式需要占据大块的页面空间，查看起来很不方便。为此，Django提供了一种扁平化
        的显示方式，你仅仅只需要修改一下 ChoiceInline 继承的类为 admin.TabularInline 替代先前的 StackedInline 类（其实，从类名上你就能看出两种父类的区别）。

        # polls/admin.py
        class ChoiceInline(admin.TabularInline):
            #...
            
     三、定制实例列表页面
        Question的添加和修改页面我们已经修改得差不多了，下面让我们来装饰一下“实例列表”(change list)页面，该页面显示了当前系统中所有
        的questions实例。
        
        通常，Django只显示 __str()__ 方法指定的内容。但是很多时候，我们可能要同时显示一些别的内容。要实现这一目的，可以使用 
        list_display 属性，它是一个由字段组成的元组，其中的每一个字段都会按顺序显示在“change list”页面上，代码如下：

        # polls/admin.py
        class QuestionAdmin(admin.ModelAdmin):
            # ...
            list_display = ('question_text', 'pub_date', 'was_published_recently')

        额外的，我们把 was_published_recently() 方法的结果也显示出来。
        
         以上的定制功能还不是admin的全部，我们接着往下看！
        我们还可以 对显示结果进行过滤 !使用 list_filter 属性，在 polls/admin.py 的QuestionAdmin中添加下面的代码：
        list_filter = ['pub_date']
        再次刷新change list页面，你会看到在页面右边多出了一个基于 pub_date 的过滤面板，如下图所示：
        根据你选择的过滤条件的不同，Django会在面板中添加不同的过滤选项。由于 pub_date 是一个 DateTimeField ，
        因此Django自动添加了这些选项：“Any date”, “Today”, “Past 7 days”, “This month”, “This year”。
        顺理成章的，让我们添加一些搜索的能力：
        search_fields = ['question_text']
        这会在页面的顶部增加一个搜索框。当输入搜索关键字后，Django会在 question_text 字段内进行搜索。只要你愿意，
        你可以使用任意多个搜索字段，Django在后台使用的都是SQL查询语句的LIKE语法，但是有限制的搜索字段有助于后台的数据库查询效率。
        其实，这个页面还提供分页功能，默认每页显示100条，只是我们的实例只有一个，囧，所以看到分页链接。
     四、定制admin整体界面
        很明显，在每一个项目的admin页面顶端都显示 Django administration 是很可笑的，它仅仅是个占位文本。利用Django的模板系统，
        我们可以快速修改它。
        1.定制项目模板
        在 manage.py 文件同级下创建一个 templates 目录。然后，打开设置文件 mysite/settings.py ，在TEMPLATES条目中添加一个DIRS选项：
        # mysite/settings.py
        TEMPLATES = [
            {
                'BACKEND': 'django.template.backends.django.DjangoTemplates',
                'DIRS': [os.path.join(BASE_DIR, 'templates')],  # 要有这一行，如果已经存在请保持原样
                'APP_DIRS': True,
                'OPTIONS': {
                    'context_processors': [
                        'django.template.context_processors.debug',
                        'django.template.context_processors.request',
                        'django.contrib.auth.context_processors.auth',
                        'django.contrib.messages.context_processors.messages',
                    ],
                },
            },
        ]
        DIRS是一个文件系统目录的列表，是模板的搜索路径。当加载Django模板时，会在DIRS中进行查找。
        PS：模板的组织方式
        就像静态文件一样，我们可以把所有的模板都放在一起，形成一个大大的模板文件夹，并且工作正常。但是请一定不要这么做！
        强烈建议每一个模板都应该存放在它所属应用的模板目录内（例如polls/templates）而不是整个项目的模板目录（templates），
        因为这样每个应用才可以被方便和正确的重用。只有对整个项目有作用的模板文件才放在根目录的templates中，比如admin界面。
        回到刚才创建的templates目录中，再创建一个admin目录，将 admin/base_site.html 模板文件拷贝到该目录内。这个HTML文件来自Django源码
        ，它位于 django/contrib/admin/templates 目录内。
        （在我的windows系统中，它位于 C:\Python36\Lib\site-packages\django\contrib\admin\templates\admin ，请大家参考。）
        Django的源代码在哪里？
        如果你无法找到Django源代码文件的存放位置，可以使用下面的命令：
        $ python -c "import django; print(django.__path__)"
        编辑 base_site.html 文件，用你喜欢的站点名字替换掉 {{ site_header|default:_(’Django administration’) }} 
        （包括两个大括号一起替换掉），看起来像下面这样：
        {% extends "admin/base.html" %}
        {% block title %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}
        {% block branding %}
        <h1 id="site-name"><a href="{% url 'admin:index' %}">投票站点管理界面</a></h1>
        {% endblock %}
        {% block nav-global %}{% endblock %}
        在这里，我们使用的是硬编码，强行改名为"投票站点管理界面"。但是在实际的项目中，你可以使用 django.contrib.admin.AdminSite.site_header 
        属性，方便的对这个页面title进行自定义。
        修改完后，刷新页面，效果如下：
        提示：所有Django默认的admin模板都可以被重写，类似刚才重写 base_site.html 模板的方法一样，从源代码目录将HTML文件拷贝至你
        自定义的目录内，然后修改文件。
    五、定制admin首页
        默认情况下，admin首页显示所有 INSTALLED_APPS 内并在admin应用中注册过的app，以字母顺序进行排序。
        要定制admin首页，你需要重写 admin/index.html 模板，就像前面修改 base_site.html 模板的方法一样，从源码目录拷贝到你指定的目录内。
        编辑该文件，你会看到文件内使用了一个 app_list 模板变量。该变量包含了所有已经安装的Django应用。你可以硬编码链接到指定对象的admin页面，
        使用任何你认为好的方法，用于替代这个 app_list 。

22.
23.
24.
25.
